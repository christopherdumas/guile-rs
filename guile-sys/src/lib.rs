/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __GMP_HAVE_HOST_CPU_FAMILY_power: ::std::os::raw::c_uint = 0;
pub const __GMP_HAVE_HOST_CPU_FAMILY_powerpc: ::std::os::raw::c_uint = 0;
pub const GMP_LIMB_BITS: ::std::os::raw::c_uint = 64;
pub const GMP_NAIL_BITS: ::std::os::raw::c_uint = 0;
pub const GMP_NUMB_BITS: ::std::os::raw::c_uint = 64;
pub const __GNU_MP__: ::std::os::raw::c_uint = 6;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __DARWIN_CLK_TCK: ::std::os::raw::c_uint = 100;
pub const CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 6;
pub const CLK_TCK: ::std::os::raw::c_uint = 100;
pub const SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const CHAR_MAX: ::std::os::raw::c_uint = 127;
pub const CHAR_MIN: ::std::os::raw::c_int = -128;
pub const USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const ULONG_MAX: ::std::os::raw::c_int = -1;
pub const LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const LONG_BIT: ::std::os::raw::c_uint = 64;
pub const SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const WORD_BIT: ::std::os::raw::c_uint = 32;
pub const SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 266;
pub const GID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const LINK_MAX: ::std::os::raw::c_uint = 32767;
pub const MAX_CANON: ::std::os::raw::c_uint = 1024;
pub const MAX_INPUT: ::std::os::raw::c_uint = 1024;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 16;
pub const UID_MAX: ::std::os::raw::c_uint = 2147483647;
pub const OPEN_MAX: ::std::os::raw::c_uint = 10240;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const NZERO: ::std::os::raw::c_uint = 20;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 512;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 8192;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_SS_REPL_MAX: ::std::os::raw::c_uint = 4;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 30;
pub const _POSIX_TRACE_NAME_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_SYS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const PASS_MAX: ::std::os::raw::c_uint = 128;
pub const NL_ARGMAX: ::std::os::raw::c_uint = 9;
pub const NL_LANGMAX: ::std::os::raw::c_uint = 14;
pub const NL_MSGMAX: ::std::os::raw::c_uint = 32767;
pub const NL_NMAX: ::std::os::raw::c_uint = 1;
pub const NL_SETMAX: ::std::os::raw::c_uint = 255;
pub const NL_TEXTMAX: ::std::os::raw::c_uint = 2048;
pub const _XOPEN_IOV_MAX: ::std::os::raw::c_uint = 16;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const _XOPEN_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _XOPEN_PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const __GMP_LIBGMP_DLL: ::std::os::raw::c_uint = 0;
pub const __GMP_MP_SIZE_T_INT: ::std::os::raw::c_uint = 0;
pub const __GMP_INLINE_PROTOTYPES: ::std::os::raw::c_uint = 1;
pub const __GMP_CC: &'static [u8; 6usize] = b"clang\x00";
pub const __GMP_CFLAGS: &'static [u8; 66usize] =
    b"-O2 -pedantic -fomit-frame-pointer -m64 -mtune=core2 -march=core2\x00";
pub const __GNU_MP_VERSION: ::std::os::raw::c_uint = 6;
pub const __GNU_MP_VERSION_MINOR: ::std::os::raw::c_uint = 1;
pub const __GNU_MP_VERSION_PATCHLEVEL: ::std::os::raw::c_uint = 2;
pub const __GNU_MP_RELEASE: ::std::os::raw::c_uint = 60102;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101204;
pub const __DARWIN_FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __DARWIN_NBBY: ::std::os::raw::c_uint = 8;
pub const ITIMER_REAL: ::std::os::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const ITIMER_PROF: ::std::os::raw::c_uint = 2;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const DST_NONE: ::std::os::raw::c_uint = 0;
pub const DST_USA: ::std::os::raw::c_uint = 1;
pub const DST_AUST: ::std::os::raw::c_uint = 2;
pub const DST_WET: ::std::os::raw::c_uint = 3;
pub const DST_MET: ::std::os::raw::c_uint = 4;
pub const DST_EET: ::std::os::raw::c_uint = 5;
pub const DST_CAN: ::std::os::raw::c_uint = 6;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const CLOCKS_PER_SEC: ::std::os::raw::c_uint = 1000000;
pub const SCM_HAVE_STDC_HEADERS: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NSIG: ::std::os::raw::c_uint = 32;
pub const NSIG: ::std::os::raw::c_uint = 32;
pub const _I386_SIGNAL_H_: ::std::os::raw::c_uint = 1;
pub const SIGHUP: ::std::os::raw::c_uint = 1;
pub const SIGINT: ::std::os::raw::c_uint = 2;
pub const SIGQUIT: ::std::os::raw::c_uint = 3;
pub const SIGILL: ::std::os::raw::c_uint = 4;
pub const SIGTRAP: ::std::os::raw::c_uint = 5;
pub const SIGABRT: ::std::os::raw::c_uint = 6;
pub const SIGIOT: ::std::os::raw::c_uint = 6;
pub const SIGEMT: ::std::os::raw::c_uint = 7;
pub const SIGFPE: ::std::os::raw::c_uint = 8;
pub const SIGKILL: ::std::os::raw::c_uint = 9;
pub const SIGBUS: ::std::os::raw::c_uint = 10;
pub const SIGSEGV: ::std::os::raw::c_uint = 11;
pub const SIGSYS: ::std::os::raw::c_uint = 12;
pub const SIGPIPE: ::std::os::raw::c_uint = 13;
pub const SIGALRM: ::std::os::raw::c_uint = 14;
pub const SIGTERM: ::std::os::raw::c_uint = 15;
pub const SIGURG: ::std::os::raw::c_uint = 16;
pub const SIGSTOP: ::std::os::raw::c_uint = 17;
pub const SIGTSTP: ::std::os::raw::c_uint = 18;
pub const SIGCONT: ::std::os::raw::c_uint = 19;
pub const SIGCHLD: ::std::os::raw::c_uint = 20;
pub const SIGTTIN: ::std::os::raw::c_uint = 21;
pub const SIGTTOU: ::std::os::raw::c_uint = 22;
pub const SIGIO: ::std::os::raw::c_uint = 23;
pub const SIGXCPU: ::std::os::raw::c_uint = 24;
pub const SIGXFSZ: ::std::os::raw::c_uint = 25;
pub const SIGVTALRM: ::std::os::raw::c_uint = 26;
pub const SIGPROF: ::std::os::raw::c_uint = 27;
pub const SIGWINCH: ::std::os::raw::c_uint = 28;
pub const SIGINFO: ::std::os::raw::c_uint = 29;
pub const SIGUSR1: ::std::os::raw::c_uint = 30;
pub const SIGUSR2: ::std::os::raw::c_uint = 31;
pub const FP_PREC_24B: ::std::os::raw::c_uint = 0;
pub const FP_PREC_53B: ::std::os::raw::c_uint = 2;
pub const FP_PREC_64B: ::std::os::raw::c_uint = 3;
pub const FP_RND_NEAR: ::std::os::raw::c_uint = 0;
pub const FP_RND_DOWN: ::std::os::raw::c_uint = 1;
pub const FP_RND_UP: ::std::os::raw::c_uint = 2;
pub const FP_CHOP: ::std::os::raw::c_uint = 3;
pub const FP_STATE_BYTES: ::std::os::raw::c_uint = 512;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 0;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 3;
pub const ILL_NOOP: ::std::os::raw::c_uint = 0;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 2;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 3;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 4;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub const FPE_NOOP: ::std::os::raw::c_uint = 0;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 3;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 4;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 5;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 6;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 7;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 8;
pub const SEGV_NOOP: ::std::os::raw::c_uint = 0;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub const BUS_NOOP: ::std::os::raw::c_uint = 0;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const TRAP_BRKPT: ::std::os::raw::c_uint = 1;
pub const TRAP_TRACE: ::std::os::raw::c_uint = 2;
pub const CLD_NOOP: ::std::os::raw::c_uint = 0;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub const SA_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SA_RESTART: ::std::os::raw::c_uint = 2;
pub const SA_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SA_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SA_NODEFER: ::std::os::raw::c_uint = 16;
pub const SA_NOCLDWAIT: ::std::os::raw::c_uint = 32;
pub const SA_SIGINFO: ::std::os::raw::c_uint = 64;
pub const SA_USERTRAMP: ::std::os::raw::c_uint = 256;
pub const SA_64REGSET: ::std::os::raw::c_uint = 512;
pub const SA_USERSPACE_MASK: ::std::os::raw::c_uint = 127;
pub const SIG_BLOCK: ::std::os::raw::c_uint = 1;
pub const SIG_UNBLOCK: ::std::os::raw::c_uint = 2;
pub const SIG_SETMASK: ::std::os::raw::c_uint = 3;
pub const SI_USER: ::std::os::raw::c_uint = 65537;
pub const SI_QUEUE: ::std::os::raw::c_uint = 65538;
pub const SI_TIMER: ::std::os::raw::c_uint = 65539;
pub const SI_ASYNCIO: ::std::os::raw::c_uint = 65540;
pub const SI_MESGQ: ::std::os::raw::c_uint = 65541;
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 4;
pub const MINSIGSTKSZ: ::std::os::raw::c_uint = 32768;
pub const SIGSTKSZ: ::std::os::raw::c_uint = 131072;
pub const SV_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SV_INTERRUPT: ::std::os::raw::c_uint = 2;
pub const SV_RESETHAND: ::std::os::raw::c_uint = 4;
pub const SV_NODEFER: ::std::os::raw::c_uint = 16;
pub const SV_NOCLDSTOP: ::std::os::raw::c_uint = 8;
pub const SV_SIGINFO: ::std::os::raw::c_uint = 64;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const PRIO_DARWIN_THREAD: ::std::os::raw::c_uint = 3;
pub const PRIO_DARWIN_PROCESS: ::std::os::raw::c_uint = 4;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_DARWIN_BG: ::std::os::raw::c_uint = 4096;
pub const PRIO_DARWIN_NONUI: ::std::os::raw::c_uint = 4097;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_INFO_V0: ::std::os::raw::c_uint = 0;
pub const RUSAGE_INFO_V1: ::std::os::raw::c_uint = 1;
pub const RUSAGE_INFO_V2: ::std::os::raw::c_uint = 2;
pub const RUSAGE_INFO_V3: ::std::os::raw::c_uint = 3;
pub const RUSAGE_INFO_CURRENT: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 9;
pub const _RLIMIT_POSIX_FLAG: ::std::os::raw::c_uint = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: ::std::os::raw::c_uint = 2;
pub const RLIMIT_THREAD_CPULIMITS: ::std::os::raw::c_uint = 3;
pub const WAKEMON_ENABLE: ::std::os::raw::c_uint = 1;
pub const WAKEMON_DISABLE: ::std::os::raw::c_uint = 2;
pub const WAKEMON_GET_PARAMS: ::std::os::raw::c_uint = 4;
pub const WAKEMON_SET_DEFAULTS: ::std::os::raw::c_uint = 8;
pub const WAKEMON_MAKE_FATAL: ::std::os::raw::c_uint = 16;
pub const CPUMON_MAKE_FATAL: ::std::os::raw::c_uint = 4096;
pub const IOPOL_TYPE_DISK: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_PROCESS: ::std::os::raw::c_uint = 0;
pub const IOPOL_SCOPE_THREAD: ::std::os::raw::c_uint = 1;
pub const IOPOL_SCOPE_DARWIN_BG: ::std::os::raw::c_uint = 2;
pub const IOPOL_DEFAULT: ::std::os::raw::c_uint = 0;
pub const IOPOL_IMPORTANT: ::std::os::raw::c_uint = 1;
pub const IOPOL_PASSIVE: ::std::os::raw::c_uint = 2;
pub const IOPOL_THROTTLE: ::std::os::raw::c_uint = 3;
pub const IOPOL_UTILITY: ::std::os::raw::c_uint = 4;
pub const IOPOL_STANDARD: ::std::os::raw::c_uint = 5;
pub const IOPOL_APPLICATION: ::std::os::raw::c_uint = 5;
pub const IOPOL_NORMAL: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _WSTOPPED: ::std::os::raw::c_uint = 127;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WSTOPPED: ::std::os::raw::c_uint = 8;
pub const WCONTINUED: ::std::os::raw::c_uint = 16;
pub const WNOWAIT: ::std::os::raw::c_uint = 32;
pub const WAIT_ANY: ::std::os::raw::c_int = -1;
pub const WAIT_MYPGRP: ::std::os::raw::c_uint = 0;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const __DARWIN_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __DARWIN_PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __DARWIN_BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const SCM_HAVE_SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const SCM_HAVE_WINSOCK2_H: ::std::os::raw::c_uint = 0;
pub const SCM_ENABLE_DEPRECATED: ::std::os::raw::c_uint = 1;
pub const SCM_STACK_GROWS_UP: ::std::os::raw::c_uint = 0;
pub const SCM_SIZEOF_CHAR: ::std::os::raw::c_uint = 1;
pub const SCM_SIZEOF_UNSIGNED_CHAR: ::std::os::raw::c_uint = 1;
pub const SCM_SIZEOF_SHORT: ::std::os::raw::c_uint = 2;
pub const SCM_SIZEOF_UNSIGNED_SHORT: ::std::os::raw::c_uint = 2;
pub const SCM_SIZEOF_LONG: ::std::os::raw::c_uint = 8;
pub const SCM_SIZEOF_UNSIGNED_LONG: ::std::os::raw::c_uint = 8;
pub const SCM_SIZEOF_INT: ::std::os::raw::c_uint = 4;
pub const SCM_SIZEOF_UNSIGNED_INT: ::std::os::raw::c_uint = 4;
pub const SCM_SIZEOF_SIZE_T: ::std::os::raw::c_uint = 8;
pub const SCM_SIZEOF_LONG_LONG: ::std::os::raw::c_uint = 8;
pub const SCM_SIZEOF_UNSIGNED_LONG_LONG: ::std::os::raw::c_uint = 8;
pub const SCM_SIZEOF_INTMAX: ::std::os::raw::c_uint = 8;
pub const SCM_HAVE_T_INT64: ::std::os::raw::c_uint = 1;
pub const SCM_HAVE_T_UINT64: ::std::os::raw::c_uint = 1;
pub const SCM_SIZEOF_SCM_T_PTRDIFF: ::std::os::raw::c_uint = 8;
pub const SCM_SIZEOF_INTPTR_T: ::std::os::raw::c_uint = 8;
pub const SCM_SIZEOF_UINTPTR_T: ::std::os::raw::c_uint = 8;
pub const SCM_USE_PTHREAD_THREADS: ::std::os::raw::c_uint = 1;
pub const SCM_USE_NULL_THREADS: ::std::os::raw::c_uint = 0;
pub const SCM_NEED_BRACES_ON_PTHREAD_ONCE_INIT: ::std::os::raw::c_uint = 0;
pub const SCM_NEED_BRACES_ON_PTHREAD_MUTEX_INITIALIZER: ::std::os::raw::c_uint
          =
    0;
pub const SCM_HAVE_GC_PTHREAD_CANCEL: ::std::os::raw::c_uint = 0;
pub const SCM_HAVE_GC_PTHREAD_EXIT: ::std::os::raw::c_uint = 0;
pub const SCM_HAVE_GC_PTHREAD_SIGMASK: ::std::os::raw::c_uint = 0;
pub const SCM_HAVE_STRUCT_DIRENT64: ::std::os::raw::c_uint = 0;
pub const SCM_HAVE_READDIR64_R: ::std::os::raw::c_uint = 0;
pub const SCM_T_OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SCM_T_OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const SCM_HAVE_ARRAYS: ::std::os::raw::c_uint = 1;
pub const SCM_ICONVEH_ERROR: ::std::os::raw::c_uint = 0;
pub const SCM_ICONVEH_QUESTION_MARK: ::std::os::raw::c_uint = 1;
pub const SCM_ICONVEH_ESCAPE_SEQUENCE: ::std::os::raw::c_uint = 2;
pub const SCM_CAN_INLINE: ::std::os::raw::c_uint = 1;
pub const SCM_DEBUG: ::std::os::raw::c_uint = 0;
pub const SCM_DEBUG_PAIR_ACCESSES: ::std::os::raw::c_uint = 0;
pub const SCM_DEBUG_REST_ARGUMENT: ::std::os::raw::c_uint = 0;
pub const SCM_DEBUG_TYPING_STRICTNESS: ::std::os::raw::c_uint = 1;
pub const SCM_CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const SCM_LONG_BIT: ::std::os::raw::c_uint = 64;
pub const scm_tc2_int: ::std::os::raw::c_uint = 2;
pub const scm_tc3_cons: ::std::os::raw::c_uint = 0;
pub const scm_tc3_struct: ::std::os::raw::c_uint = 1;
pub const scm_tc3_int_1: ::std::os::raw::c_uint = 2;
pub const scm_tc3_unused: ::std::os::raw::c_uint = 3;
pub const scm_tc3_imm24: ::std::os::raw::c_uint = 4;
pub const scm_tc3_tc7_1: ::std::os::raw::c_uint = 5;
pub const scm_tc3_int_2: ::std::os::raw::c_uint = 6;
pub const scm_tc3_tc7_2: ::std::os::raw::c_uint = 7;
pub const scm_tc7_symbol: ::std::os::raw::c_uint = 5;
pub const scm_tc7_variable: ::std::os::raw::c_uint = 7;
pub const scm_tc7_vector: ::std::os::raw::c_uint = 13;
pub const scm_tc7_wvect: ::std::os::raw::c_uint = 15;
pub const scm_tc7_string: ::std::os::raw::c_uint = 21;
pub const scm_tc7_number: ::std::os::raw::c_uint = 23;
pub const scm_tc7_hashtable: ::std::os::raw::c_uint = 29;
pub const scm_tc7_pointer: ::std::os::raw::c_uint = 31;
pub const scm_tc7_fluid: ::std::os::raw::c_uint = 37;
pub const scm_tc7_stringbuf: ::std::os::raw::c_uint = 39;
pub const scm_tc7_dynamic_state: ::std::os::raw::c_uint = 45;
pub const scm_tc7_frame: ::std::os::raw::c_uint = 47;
pub const scm_tc7_keyword: ::std::os::raw::c_uint = 53;
pub const scm_tc7_atomic_box: ::std::os::raw::c_uint = 55;
pub const scm_tc7_syntax: ::std::os::raw::c_uint = 61;
pub const scm_tc7_unused_3f: ::std::os::raw::c_uint = 63;
pub const scm_tc7_program: ::std::os::raw::c_uint = 69;
pub const scm_tc7_vm_cont: ::std::os::raw::c_uint = 71;
pub const scm_tc7_bytevector: ::std::os::raw::c_uint = 77;
pub const scm_tc7_unused_4f: ::std::os::raw::c_uint = 79;
pub const scm_tc7_weak_set: ::std::os::raw::c_uint = 85;
pub const scm_tc7_weak_table: ::std::os::raw::c_uint = 87;
pub const scm_tc7_array: ::std::os::raw::c_uint = 93;
pub const scm_tc7_bitvector: ::std::os::raw::c_uint = 95;
pub const scm_tc7_unused_65: ::std::os::raw::c_uint = 101;
pub const scm_tc7_unused_67: ::std::os::raw::c_uint = 103;
pub const scm_tc7_unused_6d: ::std::os::raw::c_uint = 109;
pub const scm_tc7_unused_6f: ::std::os::raw::c_uint = 111;
pub const scm_tc7_unused_75: ::std::os::raw::c_uint = 117;
pub const scm_tc7_smob: ::std::os::raw::c_uint = 119;
pub const scm_tc7_port: ::std::os::raw::c_uint = 125;
pub const scm_tc7_unused_7f: ::std::os::raw::c_uint = 127;
pub const _JBLEN: ::std::os::raw::c_uint = 37;
pub const SCM_ARGn: ::std::os::raw::c_uint = 0;
pub const SCM_ARG1: ::std::os::raw::c_uint = 1;
pub const SCM_ARG2: ::std::os::raw::c_uint = 2;
pub const SCM_ARG3: ::std::os::raw::c_uint = 3;
pub const SCM_ARG4: ::std::os::raw::c_uint = 4;
pub const SCM_ARG5: ::std::os::raw::c_uint = 5;
pub const SCM_ARG6: ::std::os::raw::c_uint = 6;
pub const SCM_ARG7: ::std::os::raw::c_uint = 7;
pub const SCM_CODEPOINT_DOTTED_CIRCLE: ::std::os::raw::c_uint = 9676;
pub const SCM_CODEPOINT_SURROGATE_START: ::std::os::raw::c_uint = 55296;
pub const SCM_CODEPOINT_SURROGATE_END: ::std::os::raw::c_uint = 57343;
pub const SCM_CODEPOINT_MAX: ::std::os::raw::c_uint = 1114111;
pub const SCM_OPTION_BOOLEAN: ::std::os::raw::c_uint = 0;
pub const SCM_OPTION_INTEGER: ::std::os::raw::c_uint = 1;
pub const SCM_OPTION_SCM: ::std::os::raw::c_uint = 2;
pub const SCM_PRINT_STATE_LAYOUT: &'static [u8; 25usize] =
    b"sruwuwuwuwuwpwuwuwurprpw\x00";
pub const SCM_I_FIXNUM_BIT: ::std::os::raw::c_uint = 62;
pub const SCM_MOST_NEGATIVE_FIXNUM: ::std::os::raw::c_longlong =
    -2305843009213693952;
pub const SCM_MOST_POSITIVE_FIXNUM: ::std::os::raw::c_ulonglong =
    2305843009213693951;
pub const scm_tc16_big: ::std::os::raw::c_uint = 279;
pub const scm_tc16_real: ::std::os::raw::c_uint = 535;
pub const scm_tc16_complex: ::std::os::raw::c_uint = 791;
pub const scm_tc16_fraction: ::std::os::raw::c_uint = 1047;
pub const SCM_I_ARRAY_FLAG_CONTIGUOUS: ::std::os::raw::c_uint = 1;
pub const SCM_DYNSTACK_HEADER_LEN: ::std::os::raw::c_uint = 2;
pub const SCM_DYNSTACK_TAG_TYPE_MASK: ::std::os::raw::c_uint = 15;
pub const SCM_DYNSTACK_TAG_FLAGS_MASK: ::std::os::raw::c_uint = 240;
pub const SCM_DYNSTACK_TAG_FLAGS_SHIFT: ::std::os::raw::c_uint = 4;
pub const SCM_DYNSTACK_TAG_LEN_SHIFT: ::std::os::raw::c_uint = 8;
pub const _PTHREAD_MUTEX_SIG_init: ::std::os::raw::c_uint = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: ::std::os::raw::c_uint =
    850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: ::std::os::raw::c_uint =
    850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: ::std::os::raw::c_uint =
    850045859;
pub const _PTHREAD_COND_SIG_init: ::std::os::raw::c_uint = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: ::std::os::raw::c_uint = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: ::std::os::raw::c_uint = 766030772;
pub const SCHED_OTHER: ::std::os::raw::c_uint = 1;
pub const SCHED_FIFO: ::std::os::raw::c_uint = 4;
pub const SCHED_RR: ::std::os::raw::c_uint = 2;
pub const __SCHED_PARAM_SIZE__: ::std::os::raw::c_uint = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: ::std::os::raw::c_int = -15;
pub const PTHREAD_CREATE_JOINABLE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_CREATE_DETACHED: ::std::os::raw::c_uint = 2;
pub const PTHREAD_INHERIT_SCHED: ::std::os::raw::c_uint = 1;
pub const PTHREAD_EXPLICIT_SCHED: ::std::os::raw::c_uint = 2;
pub const PTHREAD_CANCEL_ENABLE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_CANCEL_DISABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_DEFERRED: ::std::os::raw::c_uint = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::std::os::raw::c_uint = 0;
pub const PTHREAD_SCOPE_SYSTEM: ::std::os::raw::c_uint = 1;
pub const PTHREAD_SCOPE_PROCESS: ::std::os::raw::c_uint = 2;
pub const PTHREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 1;
pub const PTHREAD_PROCESS_PRIVATE: ::std::os::raw::c_uint = 2;
pub const PTHREAD_PRIO_NONE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_NORMAL: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_RECURSIVE: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: ::std::os::raw::c_uint = 0;
pub const scm_gc_running_p: ::std::os::raw::c_uint = 0;
pub const SCM_BYTEVECTOR_HEADER_SIZE: ::std::os::raw::c_uint = 4;
pub const SCM_F_BYTEVECTOR_CONTIGUOUS: ::std::os::raw::c_uint = 256;
pub const SCM_F_BYTEVECTOR_IMMUTABLE: ::std::os::raw::c_uint = 512;
pub const SCM_GC_BYTEVECTOR: &'static [u8; 11usize] = b"bytevector\x00";
pub const SCM_VTABLE_BASE_LAYOUT: &'static [u8; 17usize] =
    b"pruhsruhpwphuhuh\x00";
pub const scm_vtable_index_layout: ::std::os::raw::c_uint = 0;
pub const scm_vtable_index_flags: ::std::os::raw::c_uint = 1;
pub const scm_vtable_index_self: ::std::os::raw::c_uint = 2;
pub const scm_vtable_index_instance_finalize: ::std::os::raw::c_uint = 3;
pub const scm_vtable_index_instance_printer: ::std::os::raw::c_uint = 4;
pub const scm_vtable_index_name: ::std::os::raw::c_uint = 5;
pub const scm_vtable_index_size: ::std::os::raw::c_uint = 6;
pub const scm_vtable_index_reserved_7: ::std::os::raw::c_uint = 7;
pub const scm_vtable_offset_user: ::std::os::raw::c_uint = 8;
pub const SCM_APPLICABLE_BASE_LAYOUT: &'static [u8; 3usize] = b"pw\x00";
pub const SCM_APPLICABLE_WITH_SETTER_BASE_LAYOUT: &'static [u8; 5usize] =
    b"pwpw\x00";
pub const scm_applicable_struct_index_procedure: ::std::os::raw::c_uint = 0;
pub const scm_applicable_struct_index_setter: ::std::os::raw::c_uint = 1;
pub const SCM_VTABLE_FLAG_VALIDATED: ::std::os::raw::c_uint = 1;
pub const SCM_VTABLE_FLAG_VTABLE: ::std::os::raw::c_uint = 2;
pub const SCM_VTABLE_FLAG_APPLICABLE_VTABLE: ::std::os::raw::c_uint = 4;
pub const SCM_VTABLE_FLAG_APPLICABLE: ::std::os::raw::c_uint = 8;
pub const SCM_VTABLE_FLAG_SETTER_VTABLE: ::std::os::raw::c_uint = 16;
pub const SCM_VTABLE_FLAG_SETTER: ::std::os::raw::c_uint = 32;
pub const SCM_VTABLE_FLAG_SIMPLE: ::std::os::raw::c_uint = 64;
pub const SCM_VTABLE_FLAG_SIMPLE_RW: ::std::os::raw::c_uint = 128;
pub const SCM_VTABLE_FLAG_RESERVED_0: ::std::os::raw::c_uint = 256;
pub const SCM_VTABLE_FLAG_RESERVED_1: ::std::os::raw::c_uint = 512;
pub const SCM_VTABLE_FLAG_RESERVED_2: ::std::os::raw::c_uint = 1024;
pub const SCM_VTABLE_FLAG_SMOB_0: ::std::os::raw::c_uint = 2048;
pub const SCM_VTABLE_FLAG_GOOPS_0: ::std::os::raw::c_uint = 4096;
pub const SCM_VTABLE_FLAG_GOOPS_1: ::std::os::raw::c_uint = 8192;
pub const SCM_VTABLE_FLAG_GOOPS_2: ::std::os::raw::c_uint = 16384;
pub const SCM_VTABLE_FLAG_GOOPS_3: ::std::os::raw::c_uint = 32768;
pub const SCM_VTABLE_USER_FLAG_SHIFT: ::std::os::raw::c_uint = 16;
pub const SCM_DIR_FLAG_OPEN: ::std::os::raw::c_uint = 1;
pub const SCM_F_VECTOR_IMMUTABLE: ::std::os::raw::c_uint = 128;
pub const RENAME_SECLUDE: ::std::os::raw::c_uint = 1;
pub const RENAME_SWAP: ::std::os::raw::c_uint = 2;
pub const RENAME_EXCL: ::std::os::raw::c_uint = 4;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: ::std::os::raw::c_uint = 1;
pub const _POSIX_VERSION: ::std::os::raw::c_uint = 200112;
pub const _POSIX2_VERSION: ::std::os::raw::c_uint = 200112;
pub const F_OK: ::std::os::raw::c_uint = 0;
pub const X_OK: ::std::os::raw::c_uint = 1;
pub const W_OK: ::std::os::raw::c_uint = 2;
pub const R_OK: ::std::os::raw::c_uint = 4;
pub const _READ_OK: ::std::os::raw::c_uint = 512;
pub const _WRITE_OK: ::std::os::raw::c_uint = 1024;
pub const _EXECUTE_OK: ::std::os::raw::c_uint = 2048;
pub const _DELETE_OK: ::std::os::raw::c_uint = 4096;
pub const _APPEND_OK: ::std::os::raw::c_uint = 8192;
pub const _RMFILE_OK: ::std::os::raw::c_uint = 16384;
pub const _RATTR_OK: ::std::os::raw::c_uint = 32768;
pub const _WATTR_OK: ::std::os::raw::c_uint = 65536;
pub const _REXT_OK: ::std::os::raw::c_uint = 131072;
pub const _WEXT_OK: ::std::os::raw::c_uint = 262144;
pub const _RPERM_OK: ::std::os::raw::c_uint = 524288;
pub const _WPERM_OK: ::std::os::raw::c_uint = 1048576;
pub const _CHOWN_OK: ::std::os::raw::c_uint = 2097152;
pub const _ACCESS_EXTENDED_MASK: ::std::os::raw::c_uint = 4193792;
pub const SEEK_HOLE: ::std::os::raw::c_uint = 3;
pub const SEEK_DATA: ::std::os::raw::c_uint = 4;
pub const L_SET: ::std::os::raw::c_uint = 0;
pub const L_INCR: ::std::os::raw::c_uint = 1;
pub const L_XTND: ::std::os::raw::c_uint = 2;
pub const ACCESSX_MAX_DESCRIPTORS: ::std::os::raw::c_uint = 100;
pub const ACCESSX_MAX_TABLESIZE: ::std::os::raw::c_uint = 16384;
pub const _PC_LINK_MAX: ::std::os::raw::c_uint = 1;
pub const _PC_MAX_CANON: ::std::os::raw::c_uint = 2;
pub const _PC_MAX_INPUT: ::std::os::raw::c_uint = 3;
pub const _PC_NAME_MAX: ::std::os::raw::c_uint = 4;
pub const _PC_PATH_MAX: ::std::os::raw::c_uint = 5;
pub const _PC_PIPE_BUF: ::std::os::raw::c_uint = 6;
pub const _PC_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 7;
pub const _PC_NO_TRUNC: ::std::os::raw::c_uint = 8;
pub const _PC_VDISABLE: ::std::os::raw::c_uint = 9;
pub const _PC_NAME_CHARS_MAX: ::std::os::raw::c_uint = 10;
pub const _PC_CASE_SENSITIVE: ::std::os::raw::c_uint = 11;
pub const _PC_CASE_PRESERVING: ::std::os::raw::c_uint = 12;
pub const _PC_EXTENDED_SECURITY_NP: ::std::os::raw::c_uint = 13;
pub const _PC_AUTH_OPAQUE_NP: ::std::os::raw::c_uint = 14;
pub const _PC_2_SYMLINKS: ::std::os::raw::c_uint = 15;
pub const _PC_ALLOC_SIZE_MIN: ::std::os::raw::c_uint = 16;
pub const _PC_ASYNC_IO: ::std::os::raw::c_uint = 17;
pub const _PC_FILESIZEBITS: ::std::os::raw::c_uint = 18;
pub const _PC_PRIO_IO: ::std::os::raw::c_uint = 19;
pub const _PC_REC_INCR_XFER_SIZE: ::std::os::raw::c_uint = 20;
pub const _PC_REC_MAX_XFER_SIZE: ::std::os::raw::c_uint = 21;
pub const _PC_REC_MIN_XFER_SIZE: ::std::os::raw::c_uint = 22;
pub const _PC_REC_XFER_ALIGN: ::std::os::raw::c_uint = 23;
pub const _PC_SYMLINK_MAX: ::std::os::raw::c_uint = 24;
pub const _PC_SYNC_IO: ::std::os::raw::c_uint = 25;
pub const _PC_XATTR_SIZE_BITS: ::std::os::raw::c_uint = 26;
pub const _PC_MIN_HOLE_SIZE: ::std::os::raw::c_uint = 27;
pub const _CS_PATH: ::std::os::raw::c_uint = 1;
pub const STDIN_FILENO: ::std::os::raw::c_uint = 0;
pub const STDOUT_FILENO: ::std::os::raw::c_uint = 1;
pub const STDERR_FILENO: ::std::os::raw::c_uint = 2;
pub const _XOPEN_VERSION: ::std::os::raw::c_uint = 600;
pub const _XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 4;
pub const _POSIX_ADVISORY_INFO: ::std::os::raw::c_int = -1;
pub const _POSIX_ASYNCHRONOUS_IO: ::std::os::raw::c_int = -1;
pub const _POSIX_BARRIERS: ::std::os::raw::c_int = -1;
pub const _POSIX_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 200112;
pub const _POSIX_CLOCK_SELECTION: ::std::os::raw::c_int = -1;
pub const _POSIX_CPUTIME: ::std::os::raw::c_int = -1;
pub const _POSIX_FSYNC: ::std::os::raw::c_uint = 200112;
pub const _POSIX_IPV6: ::std::os::raw::c_uint = 200112;
pub const _POSIX_JOB_CONTROL: ::std::os::raw::c_uint = 200112;
pub const _POSIX_MAPPED_FILES: ::std::os::raw::c_uint = 200112;
pub const _POSIX_MEMLOCK: ::std::os::raw::c_int = -1;
pub const _POSIX_MEMLOCK_RANGE: ::std::os::raw::c_int = -1;
pub const _POSIX_MEMORY_PROTECTION: ::std::os::raw::c_uint = 200112;
pub const _POSIX_MESSAGE_PASSING: ::std::os::raw::c_int = -1;
pub const _POSIX_MONOTONIC_CLOCK: ::std::os::raw::c_int = -1;
pub const _POSIX_NO_TRUNC: ::std::os::raw::c_uint = 200112;
pub const _POSIX_PRIORITIZED_IO: ::std::os::raw::c_int = -1;
pub const _POSIX_PRIORITY_SCHEDULING: ::std::os::raw::c_int = -1;
pub const _POSIX_RAW_SOCKETS: ::std::os::raw::c_int = -1;
pub const _POSIX_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_REALTIME_SIGNALS: ::std::os::raw::c_int = -1;
pub const _POSIX_REGEXP: ::std::os::raw::c_uint = 200112;
pub const _POSIX_SAVED_IDS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_SEMAPHORES: ::std::os::raw::c_int = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_int = -1;
pub const _POSIX_SHELL: ::std::os::raw::c_uint = 200112;
pub const _POSIX_SPAWN: ::std::os::raw::c_int = -1;
pub const _POSIX_SPIN_LOCKS: ::std::os::raw::c_int = -1;
pub const _POSIX_SPORADIC_SERVER: ::std::os::raw::c_int = -1;
pub const _POSIX_SYNCHRONIZED_IO: ::std::os::raw::c_int = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 200112;
pub const _POSIX_THREAD_CPUTIME: ::std::os::raw::c_int = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: ::std::os::raw::c_int = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: ::std::os::raw::c_int = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_int = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: ::std::os::raw::c_int = -1;
pub const _POSIX_THREADS: ::std::os::raw::c_uint = 200112;
pub const _POSIX_TIMEOUTS: ::std::os::raw::c_int = -1;
pub const _POSIX_TIMERS: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_EVENT_FILTER: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_INHERIT: ::std::os::raw::c_int = -1;
pub const _POSIX_TRACE_LOG: ::std::os::raw::c_int = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_int = -1;
pub const _POSIX2_C_BIND: ::std::os::raw::c_uint = 200112;
pub const _POSIX2_C_DEV: ::std::os::raw::c_uint = 200112;
pub const _POSIX2_CHAR_TERM: ::std::os::raw::c_uint = 200112;
pub const _POSIX2_FORT_DEV: ::std::os::raw::c_int = -1;
pub const _POSIX2_FORT_RUN: ::std::os::raw::c_uint = 200112;
pub const _POSIX2_LOCALEDEF: ::std::os::raw::c_uint = 200112;
pub const _POSIX2_PBS: ::std::os::raw::c_int = -1;
pub const _POSIX2_PBS_ACCOUNTING: ::std::os::raw::c_int = -1;
pub const _POSIX2_PBS_CHECKPOINT: ::std::os::raw::c_int = -1;
pub const _POSIX2_PBS_LOCATE: ::std::os::raw::c_int = -1;
pub const _POSIX2_PBS_MESSAGE: ::std::os::raw::c_int = -1;
pub const _POSIX2_PBS_TRACK: ::std::os::raw::c_int = -1;
pub const _POSIX2_SW_DEV: ::std::os::raw::c_uint = 200112;
pub const _POSIX2_UPE: ::std::os::raw::c_uint = 200112;
pub const __ILP32_OFF32: ::std::os::raw::c_int = -1;
pub const __ILP32_OFFBIG: ::std::os::raw::c_uint = 1;
pub const __LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const __LPBIG_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _POSIX_V6_ILP32_OFF32: ::std::os::raw::c_int = -1;
pub const _POSIX_V6_ILP32_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _POSIX_V6_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _POSIX_V7_ILP32_OFF32: ::std::os::raw::c_int = -1;
pub const _POSIX_V7_ILP32_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _POSIX_V7_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _V6_ILP32_OFF32: ::std::os::raw::c_int = -1;
pub const _V6_ILP32_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _V6_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _V6_LPBIG_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _XBS5_ILP32_OFF32: ::std::os::raw::c_int = -1;
pub const _XBS5_ILP32_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _XBS5_LP64_OFF64: ::std::os::raw::c_uint = 1;
pub const _XBS5_LPBIG_OFFBIG: ::std::os::raw::c_uint = 1;
pub const _XOPEN_CRYPT: ::std::os::raw::c_uint = 1;
pub const _XOPEN_ENH_I18N: ::std::os::raw::c_uint = 1;
pub const _XOPEN_LEGACY: ::std::os::raw::c_int = -1;
pub const _XOPEN_REALTIME: ::std::os::raw::c_int = -1;
pub const _XOPEN_REALTIME_THREADS: ::std::os::raw::c_int = -1;
pub const _XOPEN_SHM: ::std::os::raw::c_uint = 1;
pub const _XOPEN_STREAMS: ::std::os::raw::c_int = -1;
pub const _XOPEN_UNIX: ::std::os::raw::c_uint = 1;
pub const _SC_ARG_MAX: ::std::os::raw::c_uint = 1;
pub const _SC_CHILD_MAX: ::std::os::raw::c_uint = 2;
pub const _SC_CLK_TCK: ::std::os::raw::c_uint = 3;
pub const _SC_NGROUPS_MAX: ::std::os::raw::c_uint = 4;
pub const _SC_OPEN_MAX: ::std::os::raw::c_uint = 5;
pub const _SC_JOB_CONTROL: ::std::os::raw::c_uint = 6;
pub const _SC_SAVED_IDS: ::std::os::raw::c_uint = 7;
pub const _SC_VERSION: ::std::os::raw::c_uint = 8;
pub const _SC_BC_BASE_MAX: ::std::os::raw::c_uint = 9;
pub const _SC_BC_DIM_MAX: ::std::os::raw::c_uint = 10;
pub const _SC_BC_SCALE_MAX: ::std::os::raw::c_uint = 11;
pub const _SC_BC_STRING_MAX: ::std::os::raw::c_uint = 12;
pub const _SC_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 13;
pub const _SC_EXPR_NEST_MAX: ::std::os::raw::c_uint = 14;
pub const _SC_LINE_MAX: ::std::os::raw::c_uint = 15;
pub const _SC_RE_DUP_MAX: ::std::os::raw::c_uint = 16;
pub const _SC_2_VERSION: ::std::os::raw::c_uint = 17;
pub const _SC_2_C_BIND: ::std::os::raw::c_uint = 18;
pub const _SC_2_C_DEV: ::std::os::raw::c_uint = 19;
pub const _SC_2_CHAR_TERM: ::std::os::raw::c_uint = 20;
pub const _SC_2_FORT_DEV: ::std::os::raw::c_uint = 21;
pub const _SC_2_FORT_RUN: ::std::os::raw::c_uint = 22;
pub const _SC_2_LOCALEDEF: ::std::os::raw::c_uint = 23;
pub const _SC_2_SW_DEV: ::std::os::raw::c_uint = 24;
pub const _SC_2_UPE: ::std::os::raw::c_uint = 25;
pub const _SC_STREAM_MAX: ::std::os::raw::c_uint = 26;
pub const _SC_TZNAME_MAX: ::std::os::raw::c_uint = 27;
pub const _SC_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 28;
pub const _SC_PAGESIZE: ::std::os::raw::c_uint = 29;
pub const _SC_MEMLOCK: ::std::os::raw::c_uint = 30;
pub const _SC_MEMLOCK_RANGE: ::std::os::raw::c_uint = 31;
pub const _SC_MEMORY_PROTECTION: ::std::os::raw::c_uint = 32;
pub const _SC_MESSAGE_PASSING: ::std::os::raw::c_uint = 33;
pub const _SC_PRIORITIZED_IO: ::std::os::raw::c_uint = 34;
pub const _SC_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 35;
pub const _SC_REALTIME_SIGNALS: ::std::os::raw::c_uint = 36;
pub const _SC_SEMAPHORES: ::std::os::raw::c_uint = 37;
pub const _SC_FSYNC: ::std::os::raw::c_uint = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 39;
pub const _SC_SYNCHRONIZED_IO: ::std::os::raw::c_uint = 40;
pub const _SC_TIMERS: ::std::os::raw::c_uint = 41;
pub const _SC_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 42;
pub const _SC_AIO_MAX: ::std::os::raw::c_uint = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 44;
pub const _SC_DELAYTIMER_MAX: ::std::os::raw::c_uint = 45;
pub const _SC_MQ_OPEN_MAX: ::std::os::raw::c_uint = 46;
pub const _SC_MAPPED_FILES: ::std::os::raw::c_uint = 47;
pub const _SC_RTSIG_MAX: ::std::os::raw::c_uint = 48;
pub const _SC_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 49;
pub const _SC_SEM_VALUE_MAX: ::std::os::raw::c_uint = 50;
pub const _SC_SIGQUEUE_MAX: ::std::os::raw::c_uint = 51;
pub const _SC_TIMER_MAX: ::std::os::raw::c_uint = 52;
pub const _SC_NPROCESSORS_CONF: ::std::os::raw::c_uint = 57;
pub const _SC_NPROCESSORS_ONLN: ::std::os::raw::c_uint = 58;
pub const _SC_2_PBS: ::std::os::raw::c_uint = 59;
pub const _SC_2_PBS_ACCOUNTING: ::std::os::raw::c_uint = 60;
pub const _SC_2_PBS_CHECKPOINT: ::std::os::raw::c_uint = 61;
pub const _SC_2_PBS_LOCATE: ::std::os::raw::c_uint = 62;
pub const _SC_2_PBS_MESSAGE: ::std::os::raw::c_uint = 63;
pub const _SC_2_PBS_TRACK: ::std::os::raw::c_uint = 64;
pub const _SC_ADVISORY_INFO: ::std::os::raw::c_uint = 65;
pub const _SC_BARRIERS: ::std::os::raw::c_uint = 66;
pub const _SC_CLOCK_SELECTION: ::std::os::raw::c_uint = 67;
pub const _SC_CPUTIME: ::std::os::raw::c_uint = 68;
pub const _SC_FILE_LOCKING: ::std::os::raw::c_uint = 69;
pub const _SC_GETGR_R_SIZE_MAX: ::std::os::raw::c_uint = 70;
pub const _SC_GETPW_R_SIZE_MAX: ::std::os::raw::c_uint = 71;
pub const _SC_HOST_NAME_MAX: ::std::os::raw::c_uint = 72;
pub const _SC_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 73;
pub const _SC_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 74;
pub const _SC_MQ_PRIO_MAX: ::std::os::raw::c_uint = 75;
pub const _SC_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 76;
pub const _SC_REGEXP: ::std::os::raw::c_uint = 77;
pub const _SC_SHELL: ::std::os::raw::c_uint = 78;
pub const _SC_SPAWN: ::std::os::raw::c_uint = 79;
pub const _SC_SPIN_LOCKS: ::std::os::raw::c_uint = 80;
pub const _SC_SPORADIC_SERVER: ::std::os::raw::c_uint = 81;
pub const _SC_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 83;
pub const _SC_THREAD_CPUTIME: ::std::os::raw::c_uint = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 85;
pub const _SC_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 86;
pub const _SC_THREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 87;
pub const _SC_THREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 89;
pub const _SC_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 91;
pub const _SC_THREAD_SPORADIC_SERVER: ::std::os::raw::c_uint = 92;
pub const _SC_THREAD_STACK_MIN: ::std::os::raw::c_uint = 93;
pub const _SC_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 94;
pub const _SC_TIMEOUTS: ::std::os::raw::c_uint = 95;
pub const _SC_THREADS: ::std::os::raw::c_uint = 96;
pub const _SC_TRACE: ::std::os::raw::c_uint = 97;
pub const _SC_TRACE_EVENT_FILTER: ::std::os::raw::c_uint = 98;
pub const _SC_TRACE_INHERIT: ::std::os::raw::c_uint = 99;
pub const _SC_TRACE_LOG: ::std::os::raw::c_uint = 100;
pub const _SC_TTY_NAME_MAX: ::std::os::raw::c_uint = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 102;
pub const _SC_V6_ILP32_OFF32: ::std::os::raw::c_uint = 103;
pub const _SC_V6_ILP32_OFFBIG: ::std::os::raw::c_uint = 104;
pub const _SC_V6_LP64_OFF64: ::std::os::raw::c_uint = 105;
pub const _SC_V6_LPBIG_OFFBIG: ::std::os::raw::c_uint = 106;
pub const _SC_IPV6: ::std::os::raw::c_uint = 118;
pub const _SC_RAW_SOCKETS: ::std::os::raw::c_uint = 119;
pub const _SC_SYMLOOP_MAX: ::std::os::raw::c_uint = 120;
pub const _SC_ATEXIT_MAX: ::std::os::raw::c_uint = 107;
pub const _SC_IOV_MAX: ::std::os::raw::c_uint = 56;
pub const _SC_PAGE_SIZE: ::std::os::raw::c_uint = 29;
pub const _SC_XOPEN_CRYPT: ::std::os::raw::c_uint = 108;
pub const _SC_XOPEN_ENH_I18N: ::std::os::raw::c_uint = 109;
pub const _SC_XOPEN_LEGACY: ::std::os::raw::c_uint = 110;
pub const _SC_XOPEN_REALTIME: ::std::os::raw::c_uint = 111;
pub const _SC_XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 112;
pub const _SC_XOPEN_SHM: ::std::os::raw::c_uint = 113;
pub const _SC_XOPEN_STREAMS: ::std::os::raw::c_uint = 114;
pub const _SC_XOPEN_UNIX: ::std::os::raw::c_uint = 115;
pub const _SC_XOPEN_VERSION: ::std::os::raw::c_uint = 116;
pub const _SC_XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 121;
pub const _SC_XBS5_ILP32_OFF32: ::std::os::raw::c_uint = 122;
pub const _SC_XBS5_ILP32_OFFBIG: ::std::os::raw::c_uint = 123;
pub const _SC_XBS5_LP64_OFF64: ::std::os::raw::c_uint = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: ::std::os::raw::c_uint = 125;
pub const _SC_SS_REPL_MAX: ::std::os::raw::c_uint = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 127;
pub const _SC_TRACE_NAME_MAX: ::std::os::raw::c_uint = 128;
pub const _SC_TRACE_SYS_MAX: ::std::os::raw::c_uint = 129;
pub const _SC_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 130;
pub const _SC_PASS_MAX: ::std::os::raw::c_uint = 131;
pub const _SC_PHYS_PAGES: ::std::os::raw::c_uint = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 35;
pub const _CS_DARWIN_USER_DIR: ::std::os::raw::c_uint = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: ::std::os::raw::c_uint = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: ::std::os::raw::c_uint = 65538;
pub const F_ULOCK: ::std::os::raw::c_uint = 0;
pub const F_LOCK: ::std::os::raw::c_uint = 1;
pub const F_TLOCK: ::std::os::raw::c_uint = 2;
pub const F_TEST: ::std::os::raw::c_uint = 3;
pub const SYNC_VOLUME_FULLSYNC: ::std::os::raw::c_uint = 1;
pub const SYNC_VOLUME_WAIT: ::std::os::raw::c_uint = 2;
pub const scm_tc7_ro_string: ::std::os::raw::c_uint = 533;
pub const SCM_I_STRINGBUF_F_WIDE: ::std::os::raw::c_uint = 1024;
pub const SCM_I_STRINGBUF_F_MUTABLE: ::std::os::raw::c_uint = 2048;
pub const SCM_OPN: ::std::os::raw::c_uint = 256;
pub const SCM_RDNG: ::std::os::raw::c_uint = 512;
pub const SCM_WRTNG: ::std::os::raw::c_uint = 1024;
pub const SCM_BUF0: ::std::os::raw::c_uint = 2048;
pub const SCM_BUFLINE: ::std::os::raw::c_uint = 4096;
pub const SCM_VTABLE_FLAG_GOOPS_CLASS: ::std::os::raw::c_uint = 4096;
pub const SCM_VTABLE_FLAG_GOOPS_VALID: ::std::os::raw::c_uint = 8192;
pub const SCM_VTABLE_FLAG_GOOPS_SLOT: ::std::os::raw::c_uint = 16384;
pub const SCM_VTABLE_FLAG_GOOPS_STATIC: ::std::os::raw::c_uint = 32768;
pub const SCM_CLASSF_METACLASS: ::std::os::raw::c_uint = 4098;
pub const SCM_CLASSF_GOOPS_VALID: ::std::os::raw::c_uint = 8192;
pub const SCM_CLASSF_GOOPS: ::std::os::raw::c_uint = 4096;
pub const SCM_CLASSF_GOOPS_OR_VALID: ::std::os::raw::c_uint = 12288;
pub const SCM_GSUBR_MAX: ::std::os::raw::c_uint = 10;
pub const scm_module_index_obarray: ::std::os::raw::c_uint = 0;
pub const scm_module_index_uses: ::std::os::raw::c_uint = 1;
pub const scm_module_index_binder: ::std::os::raw::c_uint = 2;
pub const scm_module_index_eval_closure: ::std::os::raw::c_uint = 3;
pub const scm_module_index_transformer: ::std::os::raw::c_uint = 4;
pub const scm_module_index_duplicate_handlers: ::std::os::raw::c_uint = 7;
pub const scm_module_index_import_obarray: ::std::os::raw::c_uint = 8;
pub const SCM_F_PROMISE_COMPUTED: ::std::os::raw::c_uint = 1;
pub const SCM_LINE_INCREMENTORS: u8 = b'\n';
pub const SCM_SMOB_TYPE_MASK: ::std::os::raw::c_uint = 65535;
pub const SCM_I_MAX_SMOB_TYPE_COUNT: ::std::os::raw::c_uint = 256;
pub const SCM_SOURCE_PROPERTY_FLAG_BREAK: ::std::os::raw::c_uint = 1;
pub const SCM_I_F_SYMBOL_UNINTERNED: ::std::os::raw::c_uint = 256;
pub const SCM_MAJOR_VERSION: ::std::os::raw::c_uint = 2;
pub const SCM_MINOR_VERSION: ::std::os::raw::c_uint = 2;
pub const SCM_MICRO_VERSION: ::std::os::raw::c_uint = 2;
pub const SCM_EFFECTIVE_VERSION: &'static [u8; 4usize] = b"2.2\x00";
pub const SCM_F_PROGRAM_IS_BOOT: ::std::os::raw::c_uint = 256;
pub const SCM_F_PROGRAM_IS_PRIMITIVE: ::std::os::raw::c_uint = 512;
pub const SCM_F_PROGRAM_IS_PRIMITIVE_GENERIC: ::std::os::raw::c_uint = 1024;
pub const SCM_F_PROGRAM_IS_CONTINUATION: ::std::os::raw::c_uint = 2048;
pub const SCM_F_PROGRAM_IS_PARTIAL_CONTINUATION: ::std::os::raw::c_uint =
    4096;
pub const SCM_F_PROGRAM_IS_FOREIGN: ::std::os::raw::c_uint = 8192;
pub const SCM_STACK_LAYOUT: &'static [u8; 7usize] = b"pwpwpw\x00";
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type mp_limb_t = ::std::os::raw::c_ulong;
pub type mp_limb_signed_t = ::std::os::raw::c_long;
pub type mp_bitcnt_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mpz_struct {
    pub _mp_alloc: ::std::os::raw::c_int,
    pub _mp_size: ::std::os::raw::c_int,
    pub _mp_d: *mut mp_limb_t,
}
#[test]
fn bindgen_test_layout___mpz_struct() {
    assert_eq!(::std::mem::size_of::<__mpz_struct>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __mpz_struct ) ));
    assert_eq! (::std::mem::align_of::<__mpz_struct>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mpz_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpz_struct ) ) . _mp_alloc as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpz_struct ) , "::" ,
                stringify ! ( _mp_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpz_struct ) ) . _mp_size as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpz_struct ) , "::" ,
                stringify ! ( _mp_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpz_struct ) ) . _mp_d as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpz_struct ) , "::" ,
                stringify ! ( _mp_d ) ));
}
impl Clone for __mpz_struct {
    fn clone(&self) -> Self { *self }
}
pub type MP_INT = __mpz_struct;
pub type mpz_t = [__mpz_struct; 1usize];
pub type mp_ptr = *mut mp_limb_t;
pub type mp_srcptr = *const mp_limb_t;
pub type mp_size_t = ::std::os::raw::c_long;
pub type mp_exp_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mpq_struct {
    pub _mp_num: __mpz_struct,
    pub _mp_den: __mpz_struct,
}
#[test]
fn bindgen_test_layout___mpq_struct() {
    assert_eq!(::std::mem::size_of::<__mpq_struct>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __mpq_struct ) ));
    assert_eq! (::std::mem::align_of::<__mpq_struct>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mpq_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpq_struct ) ) . _mp_num as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpq_struct ) , "::" ,
                stringify ! ( _mp_num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpq_struct ) ) . _mp_den as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpq_struct ) , "::" ,
                stringify ! ( _mp_den ) ));
}
impl Clone for __mpq_struct {
    fn clone(&self) -> Self { *self }
}
pub type MP_RAT = __mpq_struct;
pub type mpq_t = [__mpq_struct; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mpf_struct {
    pub _mp_prec: ::std::os::raw::c_int,
    pub _mp_size: ::std::os::raw::c_int,
    pub _mp_exp: mp_exp_t,
    pub _mp_d: *mut mp_limb_t,
}
#[test]
fn bindgen_test_layout___mpf_struct() {
    assert_eq!(::std::mem::size_of::<__mpf_struct>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __mpf_struct ) ));
    assert_eq! (::std::mem::align_of::<__mpf_struct>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mpf_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpf_struct ) ) . _mp_prec as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpf_struct ) , "::" ,
                stringify ! ( _mp_prec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpf_struct ) ) . _mp_size as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpf_struct ) , "::" ,
                stringify ! ( _mp_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpf_struct ) ) . _mp_exp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpf_struct ) , "::" ,
                stringify ! ( _mp_exp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mpf_struct ) ) . _mp_d as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __mpf_struct ) , "::" ,
                stringify ! ( _mp_d ) ));
}
impl Clone for __mpf_struct {
    fn clone(&self) -> Self { *self }
}
pub type mpf_t = [__mpf_struct; 1usize];
pub const gmp_randalg_t_GMP_RAND_ALG_LC: gmp_randalg_t =
    gmp_randalg_t::GMP_RAND_ALG_DEFAULT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gmp_randalg_t { GMP_RAND_ALG_DEFAULT = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gmp_randstate_struct {
    pub _mp_seed: mpz_t,
    pub _mp_alg: gmp_randalg_t,
    pub _mp_algdata: __gmp_randstate_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __gmp_randstate_struct__bindgen_ty_1 {
    pub _mp_lc: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___gmp_randstate_struct__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__gmp_randstate_struct__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               __gmp_randstate_struct__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__gmp_randstate_struct__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __gmp_randstate_struct__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gmp_randstate_struct__bindgen_ty_1 ) )
                . _mp_lc as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __gmp_randstate_struct__bindgen_ty_1 ) , "::" , stringify ! (
                _mp_lc ) ));
}
impl Clone for __gmp_randstate_struct__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___gmp_randstate_struct() {
    assert_eq!(::std::mem::size_of::<__gmp_randstate_struct>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( __gmp_randstate_struct )
               ));
    assert_eq! (::std::mem::align_of::<__gmp_randstate_struct>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __gmp_randstate_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gmp_randstate_struct ) ) . _mp_seed as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __gmp_randstate_struct
                ) , "::" , stringify ! ( _mp_seed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gmp_randstate_struct ) ) . _mp_alg as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __gmp_randstate_struct
                ) , "::" , stringify ! ( _mp_alg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __gmp_randstate_struct ) ) . _mp_algdata
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __gmp_randstate_struct
                ) , "::" , stringify ! ( _mp_algdata ) ));
}
impl Clone for __gmp_randstate_struct {
    fn clone(&self) -> Self { *self }
}
pub type gmp_randstate_t = [__gmp_randstate_struct; 1usize];
pub type mpz_srcptr = *const __mpz_struct;
pub type mpz_ptr = *mut __mpz_struct;
pub type mpf_srcptr = *const __mpf_struct;
pub type mpf_ptr = *mut __mpf_struct;
pub type mpq_srcptr = *const __mpq_struct;
pub type mpq_ptr = *mut __mpq_struct;
extern "C" {
    pub fn __gmp_set_memory_functions(arg1:
                                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         usize)
                                                                    ->
                                                                        *mut ::std::os::raw::c_void>,
                                      arg2:
                                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         *mut ::std::os::raw::c_void,
                                                                                     arg2:
                                                                                         usize,
                                                                                     arg3:
                                                                                         usize)
                                                                    ->
                                                                        *mut ::std::os::raw::c_void>,
                                      arg3:
                                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         *mut ::std::os::raw::c_void,
                                                                                     arg2:
                                                                                         usize)>);
}
extern "C" {
    pub fn __gmp_get_memory_functions(arg1:
                                          *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                              usize)
                                                                         ->
                                                                             *mut ::std::os::raw::c_void>,
                                      arg2:
                                          *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                              *mut ::std::os::raw::c_void,
                                                                                          arg2:
                                                                                              usize,
                                                                                          arg3:
                                                                                              usize)
                                                                         ->
                                                                             *mut ::std::os::raw::c_void>,
                                      arg3:
                                          *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                              *mut ::std::os::raw::c_void,
                                                                                          arg2:
                                                                                              usize)>);
}
extern "C" {
    #[link_name = "__gmp_bits_per_limb"]
    pub static __gmp_bits_per_limb: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__gmp_errno"]
    pub static mut __gmp_errno: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__gmp_version"]
    pub static __gmp_version: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmp_randinit(arg1: *mut __gmp_randstate_struct,
                          arg2: gmp_randalg_t, ...);
}
extern "C" {
    pub fn __gmp_randinit_default(arg1: *mut __gmp_randstate_struct);
}
extern "C" {
    pub fn __gmp_randinit_lc_2exp(arg1: *mut __gmp_randstate_struct,
                                  arg2: mpz_srcptr,
                                  arg3: ::std::os::raw::c_ulong,
                                  arg4: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmp_randinit_lc_2exp_size(arg1: *mut __gmp_randstate_struct,
                                       arg2: mp_bitcnt_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_randinit_mt(arg1: *mut __gmp_randstate_struct);
}
extern "C" {
    pub fn __gmp_randinit_set(arg1: *mut __gmp_randstate_struct,
                              arg2: *const __gmp_randstate_struct);
}
extern "C" {
    pub fn __gmp_randseed(arg1: *mut __gmp_randstate_struct,
                          arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmp_randseed_ui(arg1: *mut __gmp_randstate_struct,
                             arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmp_randclear(arg1: *mut __gmp_randstate_struct);
}
extern "C" {
    pub fn __gmp_urandomb_ui(arg1: *mut __gmp_randstate_struct,
                             arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmp_urandomm_ui(arg1: *mut __gmp_randstate_struct,
                             arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmp_asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                          arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_snprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_sprintf(arg1: *mut ::std::os::raw::c_char,
                         arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_sscanf(arg1: *const ::std::os::raw::c_char,
                        arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_realloc(arg1: mpz_ptr, arg2: mp_size_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __gmpz_abs(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_add(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_add_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_addmul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_addmul_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                            arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_and(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_array_init(arg1: mpz_ptr, arg2: mp_size_t, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpz_bin_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_bin_uiui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong,
                           arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_cdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr,
                              arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cdiv_q_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                            arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr,
                          arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_qr_ui(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr,
                             arg4: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr,
                              arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cdiv_r_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                            arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_ui(arg1: mpz_srcptr, arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_clear(arg1: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_clears(arg1: mpz_ptr, ...);
}
extern "C" {
    pub fn __gmpz_clrbit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cmp(arg1: mpz_srcptr, arg2: mpz_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_d(arg1: mpz_srcptr, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_si(arg1: mpz_srcptr, arg2: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_ui(arg1: mpz_srcptr, arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs(arg1: mpz_srcptr, arg2: mpz_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs_d(arg1: mpz_srcptr, arg2: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs_ui(arg1: mpz_srcptr, arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_com(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_combit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_congruent_p(arg1: mpz_srcptr, arg2: mpz_srcptr,
                              arg3: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_congruent_2exp_p(arg1: mpz_srcptr, arg2: mpz_srcptr,
                                   arg3: mp_bitcnt_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_congruent_ui_p(arg1: mpz_srcptr,
                                 arg2: ::std::os::raw::c_ulong,
                                 arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divexact(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_divexact_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                              arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_divisible_p(arg1: mpz_srcptr, arg2: mpz_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divisible_ui_p(arg1: mpz_srcptr,
                                 arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divisible_2exp_p(arg1: mpz_srcptr, arg2: mp_bitcnt_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_dump(arg1: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_export(arg1: *mut ::std::os::raw::c_void, arg2: *mut usize,
                         arg3: ::std::os::raw::c_int, arg4: usize,
                         arg5: ::std::os::raw::c_int, arg6: usize,
                         arg7: mpz_srcptr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __gmpz_fac_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_2fac_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_mfac_uiui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong,
                            arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_primorial_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr,
                              arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_fdiv_q_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                            arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr,
                          arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_qr_ui(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr,
                             arg4: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr,
                              arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_fdiv_r_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                            arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_ui(arg1: mpz_srcptr, arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fib_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fib2_ui(arg1: mpz_ptr, arg2: mpz_ptr,
                          arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fits_sint_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_slong_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_sshort_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_uint_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_ulong_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_ushort_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_gcd(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_gcd_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                         arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_gcdext(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_ptr,
                         arg4: mpz_srcptr, arg5: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_get_d(arg1: mpz_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpz_get_d_2exp(arg1: *mut ::std::os::raw::c_long,
                             arg2: mpz_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpz_get_si(arg1: mpz_srcptr) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __gmpz_get_str(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: mpz_srcptr)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpz_get_ui(arg1: mpz_srcptr) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_getlimbn(arg1: mpz_srcptr, arg2: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpz_hamdist(arg1: mpz_srcptr, arg2: mpz_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_import(arg1: mpz_ptr, arg2: usize,
                         arg3: ::std::os::raw::c_int, arg4: usize,
                         arg5: ::std::os::raw::c_int, arg6: usize,
                         arg7: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn __gmpz_init(arg1: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_init2(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_inits(arg1: mpz_ptr, ...);
}
extern "C" {
    pub fn __gmpz_init_set(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_init_set_d(arg1: mpz_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpz_init_set_si(arg1: mpz_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_init_set_str(arg1: mpz_ptr,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_init_set_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_invert(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ior(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_jacobi(arg1: mpz_srcptr, arg2: mpz_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_kronecker_si(arg1: mpz_srcptr, arg2: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_kronecker_ui(arg1: mpz_srcptr,
                               arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_si_kronecker(arg1: ::std::os::raw::c_long, arg2: mpz_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ui_kronecker(arg1: ::std::os::raw::c_ulong,
                               arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_lcm(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_lcm_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_lucnum_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_lucnum2_ui(arg1: mpz_ptr, arg2: mpz_ptr,
                             arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_millerrabin(arg1: mpz_srcptr, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_mod(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_mul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_mul_2exp(arg1: mpz_ptr, arg2: mpz_srcptr,
                           arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_mul_si(arg1: mpz_ptr, arg2: mpz_srcptr,
                         arg3: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_mul_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_neg(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_nextprime(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_perfect_power_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_perfect_square_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_popcount(arg1: mpz_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_pow_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_powm(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr,
                       arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_powm_sec(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr,
                           arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_powm_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                          arg3: ::std::os::raw::c_ulong, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_probab_prime_p(arg1: mpz_srcptr,
                                 arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_random(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_random2(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_realloc2(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_remove(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr)
     -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_root(arg1: mpz_ptr, arg2: mpz_srcptr,
                       arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_rootrem(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr,
                          arg4: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_rrandomb(arg1: mpz_ptr, arg2: *mut __gmp_randstate_struct,
                           arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_scan0(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_scan1(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_set(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_set_d(arg1: mpz_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpz_set_f(arg1: mpz_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpz_set_q(arg1: mpz_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpz_set_si(arg1: mpz_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_set_str(arg1: mpz_ptr, arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_set_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_setbit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_size(arg1: mpz_srcptr) -> usize;
}
extern "C" {
    pub fn __gmpz_sizeinbase(arg1: mpz_srcptr, arg2: ::std::os::raw::c_int)
     -> usize;
}
extern "C" {
    pub fn __gmpz_sqrt(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sqrtrem(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sub(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sub_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_ui_sub(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong,
                         arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_submul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_submul_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                            arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_swap(arg1: mpz_ptr, arg2: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_tdiv_ui(arg1: mpz_srcptr, arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr,
                              arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_tdiv_q_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                            arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr,
                          arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_qr_ui(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr,
                             arg4: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr,
                              arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_tdiv_r_ui(arg1: mpz_ptr, arg2: mpz_srcptr,
                            arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tstbit(arg1: mpz_srcptr, arg2: mp_bitcnt_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ui_pow_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong,
                            arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_urandomb(arg1: mpz_ptr, arg2: *mut __gmp_randstate_struct,
                           arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_urandomm(arg1: mpz_ptr, arg2: *mut __gmp_randstate_struct,
                           arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_xor(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_limbs_read(arg1: mpz_srcptr) -> mp_srcptr;
}
extern "C" {
    pub fn __gmpz_limbs_write(arg1: mpz_ptr, arg2: mp_size_t) -> mp_ptr;
}
extern "C" {
    pub fn __gmpz_limbs_modify(arg1: mpz_ptr, arg2: mp_size_t) -> mp_ptr;
}
extern "C" {
    pub fn __gmpz_limbs_finish(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_roinit_n(arg1: mpz_ptr, arg2: mp_srcptr, arg3: mp_size_t)
     -> mpz_srcptr;
}
extern "C" {
    pub fn __gmpq_abs(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_add(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_canonicalize(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_clear(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_clears(arg1: mpq_ptr, ...);
}
extern "C" {
    pub fn __gmpq_cmp(arg1: mpq_srcptr, arg2: mpq_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_si(arg1: mpq_srcptr, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_ui(arg1: mpq_srcptr, arg2: ::std::os::raw::c_ulong,
                         arg3: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_z(arg1: mpq_srcptr, arg2: mpz_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_div(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_div_2exp(arg1: mpq_ptr, arg2: mpq_srcptr,
                           arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpq_equal(arg1: mpq_srcptr, arg2: mpq_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_get_num(arg1: mpz_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_get_den(arg1: mpz_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_get_d(arg1: mpq_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpq_get_str(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: mpq_srcptr)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpq_init(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_inits(arg1: mpq_ptr, ...);
}
extern "C" {
    pub fn __gmpq_inv(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_mul(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_mul_2exp(arg1: mpq_ptr, arg2: mpq_srcptr,
                           arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpq_neg(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_set(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_set_d(arg1: mpq_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpq_set_den(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_set_f(arg1: mpq_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpq_set_num(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_set_si(arg1: mpq_ptr, arg2: ::std::os::raw::c_long,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpq_set_str(arg1: mpq_ptr, arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_set_ui(arg1: mpq_ptr, arg2: ::std::os::raw::c_ulong,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpq_set_z(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_sub(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_swap(arg1: mpq_ptr, arg2: mpq_ptr);
}
extern "C" {
    pub fn __gmpf_abs(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_add(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_add_ui(arg1: mpf_ptr, arg2: mpf_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_ceil(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_clear(arg1: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_clears(arg1: mpf_ptr, ...);
}
extern "C" {
    pub fn __gmpf_cmp(arg1: mpf_srcptr, arg2: mpf_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_z(arg1: mpf_srcptr, arg2: mpz_srcptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_d(arg1: mpf_srcptr, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_si(arg1: mpf_srcptr, arg2: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_ui(arg1: mpf_srcptr, arg2: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_div(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_div_2exp(arg1: mpf_ptr, arg2: mpf_srcptr,
                           arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_div_ui(arg1: mpf_ptr, arg2: mpf_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_dump(arg1: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_eq(arg1: mpf_srcptr, arg2: mpf_srcptr, arg3: mp_bitcnt_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_sint_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_slong_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_sshort_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_uint_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_ulong_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_ushort_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_floor(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_get_d(arg1: mpf_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpf_get_d_2exp(arg1: *mut ::std::os::raw::c_long,
                             arg2: mpf_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpf_get_default_prec() -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpf_get_prec(arg1: mpf_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpf_get_si(arg1: mpf_srcptr) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __gmpf_get_str(arg1: *mut ::std::os::raw::c_char,
                          arg2: *mut mp_exp_t, arg3: ::std::os::raw::c_int,
                          arg4: usize, arg5: mpf_srcptr)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpf_get_ui(arg1: mpf_srcptr) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpf_init(arg1: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_init2(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_inits(arg1: mpf_ptr, ...);
}
extern "C" {
    pub fn __gmpf_init_set(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_init_set_d(arg1: mpf_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpf_init_set_si(arg1: mpf_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpf_init_set_str(arg1: mpf_ptr,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_init_set_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_integer_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_mul(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_mul_2exp(arg1: mpf_ptr, arg2: mpf_srcptr,
                           arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_mul_ui(arg1: mpf_ptr, arg2: mpf_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_neg(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_pow_ui(arg1: mpf_ptr, arg2: mpf_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_random2(arg1: mpf_ptr, arg2: mp_size_t, arg3: mp_exp_t);
}
extern "C" {
    pub fn __gmpf_reldiff(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_set(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_set_d(arg1: mpf_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpf_set_default_prec(arg1: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_prec(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_prec_raw(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_q(arg1: mpf_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpf_set_si(arg1: mpf_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpf_set_str(arg1: mpf_ptr, arg2: *const ::std::os::raw::c_char,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_set_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_set_z(arg1: mpf_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpf_size(arg1: mpf_srcptr) -> usize;
}
extern "C" {
    pub fn __gmpf_sqrt(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_sqrt_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_sub(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_sub_ui(arg1: mpf_ptr, arg2: mpf_srcptr,
                         arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_swap(arg1: mpf_ptr, arg2: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_trunc(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_ui_div(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong,
                         arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_ui_sub(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong,
                         arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_urandomb(arg1: *mut __mpf_struct,
                           arg2: *mut __gmp_randstate_struct,
                           arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpn_add(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                      arg4: mp_srcptr, arg5: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_add_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                        arg4: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_add_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                        arg4: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_addmul_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                           arg4: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_cmp(arg1: mp_srcptr, arg2: mp_srcptr, arg3: mp_size_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_zero_p(arg1: mp_srcptr, arg2: mp_size_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_divexact_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                             arg4: mp_limb_t);
}
extern "C" {
    pub fn __gmpn_divexact_by3c(arg1: mp_ptr, arg2: mp_srcptr,
                                arg3: mp_size_t, arg4: mp_limb_t)
     -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem(arg1: mp_ptr, arg2: mp_size_t, arg3: mp_ptr,
                         arg4: mp_size_t, arg5: mp_srcptr, arg6: mp_size_t)
     -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem_1(arg1: mp_ptr, arg2: mp_size_t, arg3: mp_srcptr,
                           arg4: mp_size_t, arg5: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem_2(arg1: mp_ptr, arg2: mp_size_t, arg3: mp_ptr,
                           arg4: mp_size_t, arg5: mp_srcptr) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_div_qr_1(arg1: mp_ptr, arg2: *mut mp_limb_t,
                           arg3: mp_srcptr, arg4: mp_size_t, arg5: mp_limb_t)
     -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_div_qr_2(arg1: mp_ptr, arg2: mp_ptr, arg3: mp_srcptr,
                           arg4: mp_size_t, arg5: mp_srcptr) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcd(arg1: mp_ptr, arg2: mp_ptr, arg3: mp_size_t,
                      arg4: mp_ptr, arg5: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_gcd_1(arg1: mp_srcptr, arg2: mp_size_t, arg3: mp_limb_t)
     -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcdext_1(arg1: *mut mp_limb_signed_t,
                           arg2: *mut mp_limb_signed_t, arg3: mp_limb_t,
                           arg4: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcdext(arg1: mp_ptr, arg2: mp_ptr, arg3: *mut mp_size_t,
                         arg4: mp_ptr, arg5: mp_size_t, arg6: mp_ptr,
                         arg7: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_get_str(arg1: *mut ::std::os::raw::c_uchar,
                          arg2: ::std::os::raw::c_int, arg3: mp_ptr,
                          arg4: mp_size_t) -> usize;
}
extern "C" {
    pub fn __gmpn_hamdist(arg1: mp_srcptr, arg2: mp_srcptr, arg3: mp_size_t)
     -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_lshift(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                         arg4: ::std::os::raw::c_uint) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mod_1(arg1: mp_srcptr, arg2: mp_size_t, arg3: mp_limb_t)
     -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                      arg4: mp_srcptr, arg5: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                        arg4: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                        arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_sqr(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_neg(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t)
     -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_com(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_perfect_square_p(arg1: mp_srcptr, arg2: mp_size_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_perfect_power_p(arg1: mp_srcptr, arg2: mp_size_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_popcount(arg1: mp_srcptr, arg2: mp_size_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_pow_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                        arg4: mp_limb_t, arg5: mp_ptr) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_preinv_mod_1(arg1: mp_srcptr, arg2: mp_size_t,
                               arg3: mp_limb_t, arg4: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_random(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_random2(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_rshift(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                         arg4: ::std::os::raw::c_uint) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_scan0(arg1: mp_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_scan1(arg1: mp_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_set_str(arg1: mp_ptr, arg2: *const ::std::os::raw::c_uchar,
                          arg3: usize, arg4: ::std::os::raw::c_int)
     -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sizeinbase(arg1: mp_srcptr, arg2: mp_size_t,
                             arg3: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __gmpn_sqrtrem(arg1: mp_ptr, arg2: mp_ptr, arg3: mp_srcptr,
                          arg4: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sub(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                      arg4: mp_srcptr, arg5: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sub_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                        arg4: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sub_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                        arg4: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_submul_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                           arg4: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_tdiv_qr(arg1: mp_ptr, arg2: mp_ptr, arg3: mp_size_t,
                          arg4: mp_srcptr, arg5: mp_size_t, arg6: mp_srcptr,
                          arg7: mp_size_t);
}
extern "C" {
    pub fn __gmpn_and_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                        arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_andn_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                         arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_nand_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                         arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_ior_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                        arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_iorn_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                         arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_nior_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                         arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_xor_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                        arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_xnor_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr,
                         arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_copyi(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_copyd(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_zero(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_cnd_add_n(arg1: mp_limb_t, arg2: mp_ptr, arg3: mp_srcptr,
                            arg4: mp_srcptr, arg5: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_cnd_sub_n(arg1: mp_limb_t, arg2: mp_ptr, arg3: mp_srcptr,
                            arg4: mp_srcptr, arg5: mp_size_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_add_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                            arg4: mp_limb_t, arg5: mp_ptr) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_add_1_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_sub_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                            arg4: mp_limb_t, arg5: mp_ptr) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_sub_1_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_cnd_swap(arg1: mp_limb_t, arg2: *mut mp_limb_t,
                           arg3: *mut mp_limb_t, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_sec_mul(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                          arg4: mp_srcptr, arg5: mp_size_t, arg6: mp_ptr);
}
extern "C" {
    pub fn __gmpn_sec_mul_itch(arg1: mp_size_t, arg2: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_sqr(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                          arg4: mp_ptr);
}
extern "C" {
    pub fn __gmpn_sec_sqr_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_powm(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t,
                           arg4: mp_srcptr, arg5: mp_bitcnt_t,
                           arg6: mp_srcptr, arg7: mp_size_t, arg8: mp_ptr);
}
extern "C" {
    pub fn __gmpn_sec_powm_itch(arg1: mp_size_t, arg2: mp_bitcnt_t,
                                arg3: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_tabselect(arg1: *mut mp_limb_t, arg2: *const mp_limb_t,
                                arg3: mp_size_t, arg4: mp_size_t,
                                arg5: mp_size_t);
}
extern "C" {
    pub fn __gmpn_sec_div_qr(arg1: mp_ptr, arg2: mp_ptr, arg3: mp_size_t,
                             arg4: mp_srcptr, arg5: mp_size_t, arg6: mp_ptr)
     -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_div_qr_itch(arg1: mp_size_t, arg2: mp_size_t)
     -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_div_r(arg1: mp_ptr, arg2: mp_size_t, arg3: mp_srcptr,
                            arg4: mp_size_t, arg5: mp_ptr);
}
extern "C" {
    pub fn __gmpn_sec_div_r_itch(arg1: mp_size_t, arg2: mp_size_t)
     -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_invert(arg1: mp_ptr, arg2: mp_ptr, arg3: mp_srcptr,
                             arg4: mp_size_t, arg5: mp_bitcnt_t, arg6: mp_ptr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_sec_invert_itch(arg1: mp_size_t) -> mp_size_t;
}
pub const GMP_ERROR_NONE: _bindgen_ty_1 = _bindgen_ty_1::GMP_ERROR_NONE;
pub const GMP_ERROR_UNSUPPORTED_ARGUMENT: _bindgen_ty_1 =
    _bindgen_ty_1::GMP_ERROR_UNSUPPORTED_ARGUMENT;
pub const GMP_ERROR_DIVISION_BY_ZERO: _bindgen_ty_1 =
    _bindgen_ty_1::GMP_ERROR_DIVISION_BY_ZERO;
pub const GMP_ERROR_SQRT_OF_NEGATIVE: _bindgen_ty_1 =
    _bindgen_ty_1::GMP_ERROR_SQRT_OF_NEGATIVE;
pub const GMP_ERROR_INVALID_ARGUMENT: _bindgen_ty_1 =
    _bindgen_ty_1::GMP_ERROR_INVALID_ARGUMENT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    GMP_ERROR_NONE = 0,
    GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,
    GMP_ERROR_DIVISION_BY_ZERO = 2,
    GMP_ERROR_SQRT_OF_NEGATIVE = 4,
    GMP_ERROR_INVALID_ARGUMENT = 8,
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    assert_eq!(::std::mem::size_of::<timeval64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval64 ) ));
    assert_eq! (::std::mem::align_of::<timeval64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval64 ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval64 ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval64 ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval64 ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval64 {
    fn clone(&self) -> Self { *self }
}
pub type time_t = __darwin_time_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::std::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::std::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::std::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tickadj as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tickadj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type clock_t = __darwin_clock_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "getdate_err"]
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                    arg3: *const ::std::os::raw::c_char, arg4: *const tm)
     -> usize;
}
extern "C" {
    pub fn strptime(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, arg3: *mut tm)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clockid_t {
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16,
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::std::os::raw::c_char, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(arg1: *mut timeval, arg2: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "select$1050"]
    pub fn select(arg1: ::std::os::raw::c_int, arg2: *mut fd_set,
                  arg3: *mut fd_set, arg4: *mut fd_set, arg5: *mut timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(arg1: ::std::os::raw::c_int, arg2: *const itimerval,
                     arg3: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(arg1: *const ::std::os::raw::c_char, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_thread_state>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_thread_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_thread_state>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_thread_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eax as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eax )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebx as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ebx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ecx as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ecx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edx as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __edx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edi as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __edi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esi as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __esi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebp as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ebp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esp as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __esp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ss as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eflags
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eflags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eip as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __eip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __cs as
                * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ds as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __es as
                * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __fs as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __gs as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_thread_state ) , "::" , stringify ! ( __gs ) ));
}
impl Clone for __darwin_i386_thread_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_control {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_control>() , 2usize , concat
               ! ( "Size of: " , stringify ! ( __darwin_fp_control ) ));
    assert_eq! (::std::mem::align_of::<__darwin_fp_control>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_fp_control ) ));
}
impl Clone for __darwin_fp_control {
    fn clone(&self) -> Self { *self }
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 768u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 3072u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 3072u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__invalid: ::std::os::raw::c_ushort,
                          __denorm: ::std::os::raw::c_ushort,
                          __zdiv: ::std::os::raw::c_ushort,
                          __ovrfl: ::std::os::raw::c_ushort,
                          __undfl: ::std::os::raw::c_ushort,
                          __precis: ::std::os::raw::c_ushort,
                          __pc: ::std::os::raw::c_ushort,
                          __rc: ::std::os::raw::c_ushort) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((__invalid as u16 as u16) <<
                                                     0usize) & (1u64 as u16))
                                       } |
                                           ((__denorm as u16 as u16) <<
                                                1usize) & (2u64 as u16))
                                  } |
                                      ((__zdiv as u16 as u16) << 2usize) &
                                          (4u64 as u16))
                             } |
                                 ((__ovrfl as u16 as u16) << 3usize) &
                                     (8u64 as u16))
                        } |
                            ((__undfl as u16 as u16) << 4usize) &
                                (16u64 as u16))
                   } | ((__precis as u16 as u16) << 5usize) & (32u64 as u16))
              } | ((__pc as u16 as u16) << 8usize) & (768u64 as u16))
         } | ((__rc as u16 as u16) << 10usize) & (3072u64 as u16))
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_fp_status {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(::std::mem::size_of::<__darwin_fp_status>() , 2usize , concat !
               ( "Size of: " , stringify ! ( __darwin_fp_status ) ));
    assert_eq! (::std::mem::align_of::<__darwin_fp_status>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_fp_status ) ));
}
impl Clone for __darwin_fp_status {
    fn clone(&self) -> Self { *self }
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 8u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 8u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16u64 as u16;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 64u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 64u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 128u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 256u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 512u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 1024u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 14336u64 as u16;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 14336u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 16384u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 16384u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        let mask = 32768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__invalid: ::std::os::raw::c_ushort,
                          __denorm: ::std::os::raw::c_ushort,
                          __zdiv: ::std::os::raw::c_ushort,
                          __ovrfl: ::std::os::raw::c_ushort,
                          __undfl: ::std::os::raw::c_ushort,
                          __precis: ::std::os::raw::c_ushort,
                          __stkflt: ::std::os::raw::c_ushort,
                          __errsumm: ::std::os::raw::c_ushort,
                          __c0: ::std::os::raw::c_ushort,
                          __c1: ::std::os::raw::c_ushort,
                          __c2: ::std::os::raw::c_ushort,
                          __tos: ::std::os::raw::c_ushort,
                          __c3: ::std::os::raw::c_ushort,
                          __busy: ::std::os::raw::c_ushort) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              0
                                                                          } |
                                                                              ((__invalid
                                                                                    as
                                                                                    u16
                                                                                    as
                                                                                    u16)
                                                                                   <<
                                                                                   0usize)
                                                                                  &
                                                                                  (1u64
                                                                                       as
                                                                                       u16))
                                                                     } |
                                                                         ((__denorm
                                                                               as
                                                                               u16
                                                                               as
                                                                               u16)
                                                                              <<
                                                                              1usize)
                                                                             &
                                                                             (2u64
                                                                                  as
                                                                                  u16))
                                                                } |
                                                                    ((__zdiv
                                                                          as
                                                                          u16
                                                                          as
                                                                          u16)
                                                                         <<
                                                                         2usize)
                                                                        &
                                                                        (4u64
                                                                             as
                                                                             u16))
                                                           } |
                                                               ((__ovrfl as
                                                                     u16 as
                                                                     u16) <<
                                                                    3usize) &
                                                                   (8u64 as
                                                                        u16))
                                                      } |
                                                          ((__undfl as u16 as
                                                                u16) <<
                                                               4usize) &
                                                              (16u64 as u16))
                                                 } |
                                                     ((__precis as u16 as u16)
                                                          << 5usize) &
                                                         (32u64 as u16))
                                            } |
                                                ((__stkflt as u16 as u16) <<
                                                     6usize) & (64u64 as u16))
                                       } |
                                           ((__errsumm as u16 as u16) <<
                                                7usize) & (128u64 as u16))
                                  } |
                                      ((__c0 as u16 as u16) << 8usize) &
                                          (256u64 as u16))
                             } |
                                 ((__c1 as u16 as u16) << 9usize) &
                                     (512u64 as u16))
                        } |
                            ((__c2 as u16 as u16) << 10usize) &
                                (1024u64 as u16))
                   } | ((__tos as u16 as u16) << 11usize) & (14336u64 as u16))
              } | ((__c3 as u16 as u16) << 14usize) & (16384u64 as u16))
         } | ((__busy as u16 as u16) << 15usize) & (32768u64 as u16))
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_mmst_reg>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __darwin_mmst_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mmst_reg>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_mmst_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) ,
                "::" , stringify ! ( __mmst_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_rsrv as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) ,
                "::" , stringify ! ( __mmst_rsrv ) ));
}
impl Clone for __darwin_mmst_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(::std::mem::size_of::<__darwin_xmm_reg>() , 16usize , concat !
               ( "Size of: " , stringify ! ( __darwin_xmm_reg ) ));
    assert_eq! (::std::mem::align_of::<__darwin_xmm_reg>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( __darwin_xmm_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_xmm_reg ) ) . __xmm_reg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_xmm_reg ) ,
                "::" , stringify ! ( __xmm_reg ) ));
}
impl Clone for __darwin_xmm_reg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_float_state>() , 524usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_float_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_float_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_float_state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fcw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ftw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fop )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_mxcsr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_rsrv4 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_float_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_i386_float_state ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
}
#[repr(C)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_avx_state>() , 716usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_i386_avx_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_avx_state>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_avx_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fcw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ftw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv1
                as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_fop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ip as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_cs as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv2
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_dp as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_dp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ds as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv3
                as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_mxcsr
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm0
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm1
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm2
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm3
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm4
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm5
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm6
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm7
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm0
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm1
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm2
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm3
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm4
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm5
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm6
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm7
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_xmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv4
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh0
                as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh1
                as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh2
                as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh3
                as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh4
                as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh5
                as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh6
                as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh7
                as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_i386_avx_state
                ) , "::" , stringify ! ( __fpu_ymmh7 ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(::std::mem::size_of::<__darwin_i386_exception_state>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( __darwin_i386_exception_state ) ));
    assert_eq! (::std::mem::align_of::<__darwin_i386_exception_state>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_i386_exception_state
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) .
                __trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! (
                __trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __cpu
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! ( __cpu )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __err
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! ( __err )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_i386_exception_state ) ) .
                __faultvaddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_i386_exception_state ) , "::" , stringify ! (
                __faultvaddr ) ));
}
impl Clone for __darwin_i386_exception_state {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state32>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_debug_state32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_debug_state32>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_debug_state32 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr1 as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr2 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr3 as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr4 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr5 as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr6 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr7 as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr7 )
                ));
}
impl Clone for __darwin_x86_debug_state32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_thread_state64>() , 168usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_thread_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_thread_state64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_thread_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rax
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rax )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbx
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rcx
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rcx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdx
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdx )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdi
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsi
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsi )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbp
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsp
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r8 as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r9 as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r10
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r10 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r11
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r11 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r12
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r12 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r13
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r13 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r14
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r14 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r15
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r15 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rip
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) .
                __rflags as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rflags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __cs as
                * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __fs as
                * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __fs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __gs as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_thread_state64 ) , "::" , stringify ! ( __gs )
                ));
}
impl Clone for __darwin_x86_thread_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_float_state64>() , 524usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_float_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_float_state64>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_float_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fcw as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fcw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fsw as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fsw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_ftw as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ftw
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_fop as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fop
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_mxcsr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_stmm7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm0 as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm1 as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm2 as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm3 as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm4 as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm5 as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm6 as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm7 as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm8 as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm8
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm9 as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm9
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_xmm15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_rsrv4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_float_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_float_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
}
#[repr(C)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_avx_state64>() , 844usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_avx_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_avx_state64>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_avx_state64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_reserved as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fcw
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fcw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fsw
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fsw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ftw
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ftw )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fop
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fop )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ip
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ip )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_cs
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_cs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_dp
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_dp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ds
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ds )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_mxcsr as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_mxcsr
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_mxcsrmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm0 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm1 as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm2 as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm3 as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm4 as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm5 as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm6 as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_stmm7 as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm0
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm1
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm2
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm3
                as * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm4
                as * const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm5
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm6
                as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm7
                as * const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm7 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm8
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm8 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm9
                as * const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm9 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm10 as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm10
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm11 as * const _ as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm11
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm12 as * const _ as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm12
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm13 as * const _ as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm13
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm14 as * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm14
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_xmm15 as * const _ as usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm15
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_reserved1 as * const _ as usize } , 520usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __fpu_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __avx_reserved1 as * const _ as usize } , 524usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! (
                __avx_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh4
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh5
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh6
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh7
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh8 as * const _ as usize } , 716usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh8
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh9 as * const _ as usize } , 732usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh9
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh10 as * const _ as usize } , 748usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh10
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh11 as * const _ as usize } , 764usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh11
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh12 as * const _ as usize } , 780usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh12
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh13 as * const _ as usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh13
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh14 as * const _ as usize } , 812usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh14
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) .
                __fpu_ymmh15 as * const _ as usize } , 828usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh15
                ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_exception_state64>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( __darwin_x86_exception_state64 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_exception_state64>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_exception_state64
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! (
                __trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __cpu as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! ( __cpu
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __err as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! ( __err
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) .
                __faultvaddr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_exception_state64 ) , "::" , stringify ! (
                __faultvaddr ) ));
}
impl Clone for __darwin_x86_exception_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(::std::mem::size_of::<__darwin_x86_debug_state64>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_x86_debug_state64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_x86_debug_state64>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( __darwin_x86_debug_state64 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr1 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr2 as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr3 as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr3 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr4 as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr4 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr5 as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr5 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr6 as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr6 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr7 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr7 )
                ));
}
impl Clone for __darwin_x86_debug_state64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext32>() , 600usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_mcontext32 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __es as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __ss as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext32 ) ) . __fs as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) ,
                "::" , stringify ! ( __fs ) ));
}
#[repr(C)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx32>() , 792usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx32 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx32>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __es as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __ss as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __fs as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32
                ) , "::" , stringify ! ( __fs ) ));
}
#[repr(C)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext64>() , 712usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_mcontext64 )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __es as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __ss as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext64 ) ) . __fs as * const
                _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) ,
                "::" , stringify ! ( __fs ) ));
}
#[repr(C)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(::std::mem::size_of::<__darwin_mcontext_avx64>() , 1032usize ,
               concat ! (
               "Size of: " , stringify ! ( __darwin_mcontext_avx64 ) ));
    assert_eq! (::std::mem::align_of::<__darwin_mcontext_avx64>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_mcontext_avx64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __es as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __ss as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __fs as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64
                ) , "::" , stringify ! ( __fs ) ));
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(::std::mem::size_of::<__darwin_sigaltstack>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( __darwin_sigaltstack )
               ));
    assert_eq! (::std::mem::align_of::<__darwin_sigaltstack>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __darwin_sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_sp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_sigaltstack )
                , "::" , stringify ! ( ss_flags ) ));
}
impl Clone for __darwin_sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(::std::mem::size_of::<__darwin_ucontext>() , 56usize , concat !
               ( "Size of: " , stringify ! ( __darwin_ucontext ) ));
    assert_eq! (::std::mem::align_of::<__darwin_ucontext>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __darwin_ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_onstack as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_onstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_sigmask as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_stack as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_link as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_mcsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcontext as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __darwin_ucontext ) ,
                "::" , stringify ! ( uc_mcontext ) ));
}
impl Clone for __darwin_ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::std::os::raw::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::std::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                              sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::std::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify_function as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify_attributes as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify_attributes ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(::std::mem::size_of::<__siginfo>() , 104usize , concat ! (
               "Size of: " , stringify ! ( __siginfo ) ));
    assert_eq! (::std::mem::align_of::<__siginfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __siginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_pid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_status as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_value as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_band as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_band ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . __pad as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for __siginfo {
    fn clone(&self) -> Self { *self }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigaction_u {
    pub __sa_handler: __BindgenUnionField<::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int)>>,
    pub __sa_sigaction: __BindgenUnionField<::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                           ::std::os::raw::c_int,
                                                                                       arg2:
                                                                                           *mut __siginfo,
                                                                                       arg3:
                                                                                           *mut ::std::os::raw::c_void)>>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(::std::mem::size_of::<__sigaction_u>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __sigaction_u ) ));
    assert_eq! (::std::mem::align_of::<__sigaction_u>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction_u ) ) . __sa_handler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction_u ) , "::"
                , stringify ! ( __sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction_u ) ) . __sa_sigaction as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction_u ) , "::"
                , stringify ! ( __sa_sigaction ) ));
}
impl Clone for __sigaction_u {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut ::std::os::raw::c_void,
                                                             arg2:
                                                                 ::std::os::raw::c_int,
                                                             arg3:
                                                                 ::std::os::raw::c_int,
                                                             arg4:
                                                                 *mut siginfo_t,
                                                             arg5:
                                                                 *mut ::std::os::raw::c_void)>,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(::std::mem::size_of::<__sigaction>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __sigaction ) ));
    assert_eq! (::std::mem::align_of::<__sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . __sigaction_u as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_tramp as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_tramp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_mask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigaction ) ) . sa_flags as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for __sigaction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::std::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_u as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
pub type sig_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(::std::mem::size_of::<sigvec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigvec ) ));
    assert_eq! (::std::mem::align_of::<sigvec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_handler as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_flags ) ));
}
impl Clone for sigvec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::std::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn signal(arg1: ::std::os::raw::c_int,
                  arg2:
                      ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     ::std::os::raw::c_int)>)
     ->
         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                        ::std::os::raw::c_int,
                                                    arg2:
                                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                       ::std::os::raw::c_int)>)>;
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::std::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::std::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(::std::mem::size_of::<rusage_info_v0>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v0 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v0 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
}
impl Clone for rusage_info_v0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(::std::mem::size_of::<rusage_info_v1>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v1 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v1 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
}
impl Clone for rusage_info_v1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(::std::mem::size_of::<rusage_info_v2>() , 160usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v2 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v2 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
}
impl Clone for rusage_info_v2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(::std::mem::size_of::<rusage_info_v3>() , 232usize , concat ! (
               "Size of: " , stringify ! ( rusage_info_v3 ) ));
    assert_eq! (::std::mem::align_of::<rusage_info_v3>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_info_v3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_uuid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_user_time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_system_time as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pkg_idle_wkups as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_interrupt_wkups
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pageins as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_wired_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_wired_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_resident_size as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_resident_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_phys_footprint as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_phys_footprint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_proc_start_abstime as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_proc_start_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_proc_exit_abstime
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_proc_exit_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_user_time
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_user_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_system_time
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_pkg_idle_wkups as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_pkg_idle_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_interrupt_wkups as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_interrupt_wkups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_pageins as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_pageins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_child_elapsed_abstime as * const _ as usize } , 136usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_child_elapsed_abstime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) . ri_diskio_bytesread
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_diskio_bytesread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_diskio_byteswritten as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_diskio_byteswritten ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_default as * const _ as usize } , 160usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_maintenance as * const _ as usize } , 168usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_maintenance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_background as * const _ as usize } , 176usize
                , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_background ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_utility as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_utility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_legacy as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_legacy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_user_initiated as * const _ as usize } ,
                200usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_initiated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_cpu_time_qos_user_interactive as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_cpu_time_qos_user_interactive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_billed_system_time as * const _ as usize } , 216usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_billed_system_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_info_v3 ) ) .
                ri_serviced_system_time as * const _ as usize } , 224usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::"
                , stringify ! ( ri_serviced_system_time ) ));
}
impl Clone for rusage_info_v3 {
    fn clone(&self) -> Self { *self }
}
pub type rusage_info_current = rusage_info_v3;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::std::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::std::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(::std::mem::size_of::<proc_rlimit_control_wakeupmon>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( proc_rlimit_control_wakeupmon ) ));
    assert_eq! (::std::mem::align_of::<proc_rlimit_control_wakeupmon>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( proc_rlimit_control_wakeupmon
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) .
                wm_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                proc_rlimit_control_wakeupmon ) , "::" , stringify ! (
                wm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) .
                wm_rate as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                proc_rlimit_control_wakeupmon ) , "::" , stringify ! ( wm_rate
                ) ));
}
impl Clone for proc_rlimit_control_wakeupmon {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(arg1: ::std::os::raw::c_int, arg2: id_t,
                       arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(arg1: ::std::os::raw::c_int,
                          arg2: ::std::os::raw::c_int,
                          arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub w_T: __BindgenUnionField<wait__bindgen_ty_1>,
    pub w_S: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294901760u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294901760u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(w_Termsig: ::std::os::raw::c_uint,
                          w_Coredump: ::std::os::raw::c_uint,
                          w_Retcode: ::std::os::raw::c_uint,
                          w_Filler: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((w_Termsig as u32 as u32) << 0usize) &
                                (127u64 as u32))
                   } |
                       ((w_Coredump as u32 as u32) << 7usize) &
                           (128u64 as u32))
              } | ((w_Retcode as u32 as u32) << 8usize) & (65280u64 as u32))
         } | ((w_Filler as u32 as u32) << 16usize) & (4294901760u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294901760u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294901760u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(w_Stopval: ::std::os::raw::c_uint,
                          w_Stopsig: ::std::os::raw::c_uint,
                          w_Filler: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((w_Stopval as u32 as u32) << 0usize) &
                           (255u64 as u32))
              } | ((w_Stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
         } | ((w_Filler as u32 as u32) << 16usize) & (4294901760u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_T as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_T ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_S as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_S ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitid(arg1: idtype_t, arg2: id_t, arg3: *mut siginfo_t,
                  arg4: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(arg1: *mut ::std::os::raw::c_int,
                 arg2: ::std::os::raw::c_int, arg3: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn wait4(arg1: pid_t, arg2: *mut ::std::os::raw::c_int,
                 arg3: ::std::os::raw::c_int, arg4: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "__mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nel: usize,
                   __width: usize,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__count: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long)
     -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong,
                 arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char,
                  arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                 __width: usize,
                 __compar:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtol(__str: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtoll(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(__str: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t,
                    arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_int,
                arg4: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(arg1: f64, arg2: ::std::os::raw::c_int,
                arg3: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const *const ::std::os::raw::c_char,
                     arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(arg1: ::std::os::raw::c_uint,
                     arg2: *mut ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "realpath$DARWIN_EXTSN"]
    pub fn realpath(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __overwrite: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar,
                                arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void,
                          __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(__key: *const ::std::os::raw::c_void,
                     __base: *const ::std::os::raw::c_void, __nel: usize,
                     __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(arg1: *mut *mut ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(arg1: *const ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "daemon$1050"]
    pub fn daemon(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(arg1: dev_t, arg2: mode_t,
                     buf: *mut ::std::os::raw::c_char,
                     len: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(arg1: *mut ::std::os::raw::c_int,
                    arg2: *mut ::std::os::raw::c_long)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn heapsort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                    __width: usize,
                    __compar:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                      __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                     __width: usize,
                     __compar:
                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *const ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                       __width: usize, __compar: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(__base: *mut ::std::os::raw::c_void, __nel: usize,
                 __width: usize,
                 __compar:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn psort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, __compar: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn psort_r(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, arg1: *mut ::std::os::raw::c_void,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn qsort_b(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, __compar: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn qsort_r(__base: *mut ::std::os::raw::c_void, __nel: usize,
                   __width: usize, arg1: *mut ::std::os::raw::c_void,
                   __compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn radixsort(__base: *mut *const ::std::os::raw::c_uchar,
                     __nel: ::std::os::raw::c_int,
                     __table: *const ::std::os::raw::c_uchar,
                     __endbyte: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sradixsort(__base: *mut *const ::std::os::raw::c_uchar,
                      __nel: ::std::os::raw::c_int,
                      __table: *const ::std::os::raw::c_uchar,
                      __endbyte: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtoq(__str: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__str: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type useconds_t = __darwin_useconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type scm_t_int8 = i8;
pub type scm_t_uint8 = u8;
pub type scm_t_int16 = i16;
pub type scm_t_uint16 = u16;
pub type scm_t_int32 = i32;
pub type scm_t_uint32 = u32;
pub type scm_t_intmax = intmax_t;
pub type scm_t_uintmax = uintmax_t;
pub type scm_t_intptr = isize;
pub type scm_t_uintptr = usize;
pub type scm_t_int64 = i64;
pub type scm_t_uint64 = u64;
pub type scm_t_ptrdiff = isize;
pub type scm_t_timespec = timespec;
pub type scm_t_off = ::std::os::raw::c_long;
pub type scm_t_signed_bits = scm_t_intptr;
pub type scm_t_bits = scm_t_uintptr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_unused_struct {
    pub scm_unused_field: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_scm_unused_struct() {
    assert_eq!(::std::mem::size_of::<scm_unused_struct>() , 1usize , concat !
               ( "Size of: " , stringify ! ( scm_unused_struct ) ));
    assert_eq! (::std::mem::align_of::<scm_unused_struct>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( scm_unused_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_unused_struct ) ) . scm_unused_field
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_unused_struct ) ,
                "::" , stringify ! ( scm_unused_field ) ));
}
impl Clone for scm_unused_struct {
    fn clone(&self) -> Self { *self }
}
pub type SCM = *mut scm_unused_struct;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_tc8_tags {
    scm_tc8_flag = 4,
    scm_tc8_char = 12,
    scm_tc8_unused_0 = 20,
    scm_tc8_unused_1 = 28,
}
pub type scm_t_subr = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_dynamic_state {
    _unused: [u8; 0],
}
pub type scm_t_dynamic_state = scm_dynamic_state;
pub type jmp_buf = [::std::os::raw::c_int; 37usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 38usize];
extern "C" {
    pub fn setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut ::std::os::raw::c_int,
                   arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _setjmp(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _longjmp(arg1: *mut ::std::os::raw::c_int,
                    arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sigsetjmp(arg1: *mut ::std::os::raw::c_int,
                     arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siglongjmp(arg1: *mut ::std::os::raw::c_int,
                      arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn longjmperror();
}
pub type scm_i_jmp_buf = jmp_buf;
pub type SCM_STACKITEM = ::std::os::raw::c_long;
extern "C" {
    pub fn scm_acons(w: SCM, x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_assq(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_assv(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sloppy_assoc(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assq(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assv(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assoc(x: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assq_ref(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assv_ref(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assoc_ref(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assq_set_x(alist: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assv_set_x(alist: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assoc_set_x(alist: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assq_remove_x(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assv_remove_x(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_assoc_remove_x(alist: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_alist();
}
extern "C" {
    #[link_name = "scm_system_error_key"]
    pub static mut scm_system_error_key: SCM;
}
extern "C" {
    #[link_name = "scm_num_overflow_key"]
    pub static mut scm_num_overflow_key: SCM;
}
extern "C" {
    #[link_name = "scm_out_of_range_key"]
    pub static mut scm_out_of_range_key: SCM;
}
extern "C" {
    #[link_name = "scm_args_number_key"]
    pub static mut scm_args_number_key: SCM;
}
extern "C" {
    #[link_name = "scm_arg_type_key"]
    pub static mut scm_arg_type_key: SCM;
}
extern "C" {
    #[link_name = "scm_misc_error_key"]
    pub static mut scm_misc_error_key: SCM;
}
extern "C" {
    pub fn scm_error(key: SCM, subr: *const ::std::os::raw::c_char,
                     message: *const ::std::os::raw::c_char, args: SCM,
                     rest: SCM);
}
extern "C" {
    pub fn scm_error_scm(key: SCM, subr: SCM, message: SCM, args: SCM,
                         rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_strerror(err: SCM) -> SCM;
}
extern "C" {
    pub fn scm_syserror(subr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_syserror_msg(subr: *const ::std::os::raw::c_char,
                            message: *const ::std::os::raw::c_char, args: SCM,
                            eno: ::std::os::raw::c_int);
}
extern "C" {
    pub fn scm_num_overflow(subr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_out_of_range(subr: *const ::std::os::raw::c_char,
                            bad_value: SCM);
}
extern "C" {
    pub fn scm_out_of_range_pos(subr: *const ::std::os::raw::c_char,
                                bad_value: SCM, pos: SCM);
}
extern "C" {
    pub fn scm_wrong_num_args(proc_: SCM);
}
extern "C" {
    pub fn scm_error_num_args_subr(subr: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_wrong_type_arg(subr: *const ::std::os::raw::c_char,
                              pos: ::std::os::raw::c_int, bad_value: SCM);
}
extern "C" {
    pub fn scm_i_wrong_type_arg_symbol(symbol: SCM,
                                       pos: ::std::os::raw::c_int,
                                       bad_value: SCM);
}
extern "C" {
    pub fn scm_wrong_type_arg_msg(subr: *const ::std::os::raw::c_char,
                                  pos: ::std::os::raw::c_int, bad_value: SCM,
                                  sz: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_misc_error(subr: *const ::std::os::raw::c_char,
                          message: *const ::std::os::raw::c_char, args: SCM);
}
extern "C" {
    pub fn scm_init_error();
}
pub type scm_t_wchar = scm_t_int32;
extern "C" {
    pub fn scm_char_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_eq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_less_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_leq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_gr_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_geq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_eq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_less_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_leq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_gr_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_ci_geq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_alphabetic_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_numeric_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_whitespace_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_upper_case_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_lower_case_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_is_both_p(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_to_integer(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_integer_to_char(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_upcase(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_downcase(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_titlecase(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_general_category(chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_upcase(c: scm_t_wchar) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_c_downcase(c: scm_t_wchar) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_c_titlecase(c: scm_t_wchar) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_i_charname(chr: SCM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_charname_to_char(charname: *const ::std::os::raw::c_char,
                                  charname_len: usize) -> SCM;
}
extern "C" {
    pub fn scm_init_chars();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_option {
    pub type_: ::std::os::raw::c_uint,
    pub name: *const ::std::os::raw::c_char,
    pub val: scm_t_bits,
    pub doc: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_scm_t_option() {
    assert_eq!(::std::mem::size_of::<scm_t_option>() , 32usize , concat ! (
               "Size of: " , stringify ! ( scm_t_option ) ));
    assert_eq! (::std::mem::align_of::<scm_t_option>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_option ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_option ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_option ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_option ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_option ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_option ) ) . val as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_option ) , "::" ,
                stringify ! ( val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_option ) ) . doc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_option ) , "::" ,
                stringify ! ( doc ) ));
}
impl Clone for scm_t_option {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn scm_options_try(args: SCM, options: *mut scm_t_option,
                           s: *const ::std::os::raw::c_char,
                           dry_run: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_options(arg1: SCM, arg2: *mut scm_t_option,
                       arg3: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_init_opts(arg1:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            SCM)
                                                       -> SCM>,
                         arg2: *mut scm_t_option);
}
extern "C" {
    pub fn scm_init_options();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_print_state {
    pub handle: SCM,
    pub revealed: ::std::os::raw::c_int,
    pub writingp: ::std::os::raw::c_ulong,
    pub fancyp: ::std::os::raw::c_ulong,
    pub level: ::std::os::raw::c_ulong,
    pub length: ::std::os::raw::c_ulong,
    pub hot_ref: SCM,
    pub list_offset: ::std::os::raw::c_ulong,
    pub top: ::std::os::raw::c_ulong,
    pub ceiling: ::std::os::raw::c_ulong,
    pub ref_vect: SCM,
    pub highlight_objects: SCM,
}
#[test]
fn bindgen_test_layout_scm_print_state() {
    assert_eq!(::std::mem::size_of::<scm_print_state>() , 96usize , concat ! (
               "Size of: " , stringify ! ( scm_print_state ) ));
    assert_eq! (::std::mem::align_of::<scm_print_state>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( scm_print_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . handle as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . revealed as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( revealed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . writingp as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( writingp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . fancyp as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( fancyp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . level as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . length as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . hot_ref as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( hot_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . list_offset as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( list_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . top as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . ceiling as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( ceiling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . ref_vect as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( ref_vect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_print_state ) ) . highlight_objects
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_print_state ) ,
                "::" , stringify ! ( highlight_objects ) ));
}
impl Clone for scm_print_state {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "scm_print_state_vtable"]
    pub static mut scm_print_state_vtable: SCM;
}
extern "C" {
    #[link_name = "scm_tc16_port_with_ps"]
    pub static mut scm_tc16_port_with_ps: scm_t_bits;
}
extern "C" {
    pub fn scm_print_options(setting: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_print_state() -> SCM;
}
extern "C" {
    pub fn scm_free_print_state(print_state: SCM);
}
extern "C" {
    pub fn scm_i_port_with_print_state(port: SCM, print_state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_intprint(n: scm_t_intmax, radix: ::std::os::raw::c_int,
                        port: SCM);
}
extern "C" {
    pub fn scm_uintprint(n: scm_t_uintmax, radix: ::std::os::raw::c_int,
                         port: SCM);
}
extern "C" {
    pub fn scm_ipruk(hdr: *mut ::std::os::raw::c_char, ptr: SCM, port: SCM);
}
extern "C" {
    pub fn scm_iprlist(hdr: *mut ::std::os::raw::c_char, exp: SCM,
                       tlr: ::std::os::raw::c_int, port: SCM,
                       pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_print_symbol_name(str: *const ::std::os::raw::c_char,
                                 len: usize, port: SCM);
}
extern "C" {
    pub fn scm_prin1(exp: SCM, port: SCM, writingp: ::std::os::raw::c_int);
}
extern "C" {
    pub fn scm_iprin1(exp: SCM, port: SCM, pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_write(obj: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_display(obj: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_simple_format(port: SCM, message: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_newline(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_write_char(chr: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_printer_apply(proc_: SCM, exp: SCM, port: SCM,
                             arg1: *mut scm_print_state) -> SCM;
}
extern "C" {
    pub fn scm_port_with_print_state(port: SCM, pstate: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_print_state(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_valid_oport_value_p(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_print();
}
pub type scm_t_inum = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_double {
    pub type_: SCM,
    pub pad: SCM,
    pub real: f64,
}
#[test]
fn bindgen_test_layout_scm_t_double() {
    assert_eq!(::std::mem::size_of::<scm_t_double>() , 24usize , concat ! (
               "Size of: " , stringify ! ( scm_t_double ) ));
    assert_eq! (::std::mem::align_of::<scm_t_double>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_double ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_double ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_double ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_double ) ) . pad as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_double ) , "::" ,
                stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_double ) ) . real as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_double ) , "::" ,
                stringify ! ( real ) ));
}
impl Clone for scm_t_double {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_complex {
    pub type_: SCM,
    pub pad: SCM,
    pub real: f64,
    pub imag: f64,
}
#[test]
fn bindgen_test_layout_scm_t_complex() {
    assert_eq!(::std::mem::size_of::<scm_t_complex>() , 32usize , concat ! (
               "Size of: " , stringify ! ( scm_t_complex ) ));
    assert_eq! (::std::mem::align_of::<scm_t_complex>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_complex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_complex ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_complex ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_complex ) ) . pad as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_complex ) , "::"
                , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_complex ) ) . real as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_complex ) , "::"
                , stringify ! ( real ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_complex ) ) . imag as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_complex ) , "::"
                , stringify ! ( imag ) ));
}
impl Clone for scm_t_complex {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn scm_exact_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_exact(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_odd_p(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_even_p(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_finite_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inf_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_nan_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inf() -> SCM;
}
extern "C" {
    pub fn scm_nan() -> SCM;
}
extern "C" {
    pub fn scm_abs(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_modulo(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_euclidean_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_euclidean_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_euclidean_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_floor_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_floor_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_floor_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ceiling_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_ceiling_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ceiling_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_truncate_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_truncate_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_truncate_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_centered_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_centered_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_centered_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_round_divide(x: SCM, y: SCM, q: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_round_quotient(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_round_remainder(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gcd(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lcm(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logand(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logior(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logxor(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logtest(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logbit_p(n1: SCM, n2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lognot(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_modulo_expt(n: SCM, k: SCM, m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_integer_expt(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ash(n: SCM, count: SCM) -> SCM;
}
extern "C" {
    pub fn scm_round_ash(n: SCM, count: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_extract(n: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_logcount(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_integer_length(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_euclidean_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_floor_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_ceiling_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_truncate_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_centered_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_round_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_gcd(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_lcm(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_logand(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_logior(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_logxor(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_iint2str(num: scm_t_intmax, rad: ::std::os::raw::c_int,
                        p: *mut ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn scm_iuint2str(num: scm_t_uintmax, rad: ::std::os::raw::c_int,
                         p: *mut ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn scm_number_to_string(x: SCM, radix: SCM) -> SCM;
}
extern "C" {
    pub fn scm_print_real(sexp: SCM, port: SCM, pstate: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_print_complex(sexp: SCM, port: SCM,
                             pstate: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_bigprint(exp: SCM, port: SCM, pstate: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_locale_stringn_to_number(mem: *const ::std::os::raw::c_char,
                                          len: usize,
                                          radix: ::std::os::raw::c_uint)
     -> SCM;
}
extern "C" {
    pub fn scm_i_string_to_number(str: SCM, radix: ::std::os::raw::c_uint)
     -> SCM;
}
extern "C" {
    pub fn scm_string_to_number(str: SCM, radix: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bigequal(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_real_equalp(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_complex_equalp(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_number_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_complex_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_real_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_rational_p(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_integer_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exact_integer_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inexact_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_inexact(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_num_eq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_less_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gr_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_leq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_geq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_zero_p(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_positive_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_negative_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_max(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_min(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sum(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_oneplus(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_difference(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_oneminus(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_product(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_divide(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_floor(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ceiling(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_truncate(x: f64) -> f64;
}
extern "C" {
    pub fn scm_c_round(x: f64) -> f64;
}
extern "C" {
    pub fn scm_truncate_number(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_round_number(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_expt(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sin(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cos(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tan(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sinh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cosh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tanh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_asin(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_acos(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_atan(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_asinh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_acosh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_atanh(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_rectangular(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_polar(z1: SCM, z2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_real_part(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_imag_part(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_magnitude(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_angle(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exact_to_inexact(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inexact_to_exact(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_trunc(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_log(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_log10(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exp(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sqrt(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exact_integer_sqrt(k: SCM, s: *mut SCM, r: *mut SCM);
}
extern "C" {
    pub fn scm_i_min(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_max(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_sum(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_difference(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_product(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_divide(x: SCM, y: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_exact_integer_sqrt(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_mkbig() -> SCM;
}
extern "C" {
    pub fn scm_i_normbig(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_bigcmp(a: SCM, b: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_dbl2big(d: f64) -> SCM;
}
extern "C" {
    pub fn scm_i_dbl2num(d: f64) -> SCM;
}
extern "C" {
    pub fn scm_i_big2dbl(b: SCM) -> f64;
}
extern "C" {
    pub fn scm_i_long2big(n: ::std::os::raw::c_long) -> SCM;
}
extern "C" {
    pub fn scm_i_ulong2big(n: ::std::os::raw::c_ulong) -> SCM;
}
extern "C" {
    pub fn scm_i_clonebig(src_big: SCM, same_sign_p: ::std::os::raw::c_int)
     -> SCM;
}
extern "C" {
    pub fn scm_rationalize(x: SCM, err: SCM) -> SCM;
}
extern "C" {
    pub fn scm_numerator(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_denominator(z: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_fraction2double(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_i_fraction_equalp(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_print_fraction(sexp: SCM, port: SCM,
                                pstate: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_print_double(val: f64, port: SCM);
}
extern "C" {
    pub fn scm_i_print_complex(real: f64, imag: f64, port: SCM);
}
extern "C" {
    pub fn scm_is_integer(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_exact_integer(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_signed_integer(val: SCM, min: scm_t_intmax,
                                 max: scm_t_intmax) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_unsigned_integer(val: SCM, min: scm_t_uintmax,
                                   max: scm_t_uintmax)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_from_signed_integer(val: scm_t_intmax) -> SCM;
}
extern "C" {
    pub fn scm_from_unsigned_integer(val: scm_t_uintmax) -> SCM;
}
extern "C" {
    pub fn scm_to_signed_integer(val: SCM, min: scm_t_intmax,
                                 max: scm_t_intmax) -> scm_t_intmax;
}
extern "C" {
    pub fn scm_to_unsigned_integer(val: SCM, min: scm_t_uintmax,
                                   max: scm_t_uintmax) -> scm_t_uintmax;
}
extern "C" {
    pub fn scm_to_int8(x: SCM) -> scm_t_int8;
}
extern "C" {
    pub fn scm_from_int8(x: scm_t_int8) -> SCM;
}
extern "C" {
    pub fn scm_to_uint8(x: SCM) -> scm_t_uint8;
}
extern "C" {
    pub fn scm_from_uint8(x: scm_t_uint8) -> SCM;
}
extern "C" {
    pub fn scm_to_int16(x: SCM) -> scm_t_int16;
}
extern "C" {
    pub fn scm_from_int16(x: scm_t_int16) -> SCM;
}
extern "C" {
    pub fn scm_to_uint16(x: SCM) -> scm_t_uint16;
}
extern "C" {
    pub fn scm_from_uint16(x: scm_t_uint16) -> SCM;
}
extern "C" {
    pub fn scm_to_int32(x: SCM) -> scm_t_int32;
}
extern "C" {
    pub fn scm_from_int32(x: scm_t_int32) -> SCM;
}
extern "C" {
    pub fn scm_to_uint32(x: SCM) -> scm_t_uint32;
}
extern "C" {
    pub fn scm_from_uint32(x: scm_t_uint32) -> SCM;
}
extern "C" {
    pub fn scm_to_wchar(x: SCM) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_from_wchar(x: scm_t_wchar) -> SCM;
}
extern "C" {
    pub fn scm_to_int64(x: SCM) -> scm_t_int64;
}
extern "C" {
    pub fn scm_from_int64(x: scm_t_int64) -> SCM;
}
extern "C" {
    pub fn scm_to_uint64(x: SCM) -> scm_t_uint64;
}
extern "C" {
    pub fn scm_from_uint64(x: scm_t_uint64) -> SCM;
}
extern "C" {
    pub fn scm_to_mpz(x: SCM, rop: *mut __mpz_struct);
}
extern "C" {
    pub fn scm_from_mpz(rop: *mut __mpz_struct) -> SCM;
}
extern "C" {
    pub fn scm_is_real(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_rational(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_to_double(val: SCM) -> f64;
}
extern "C" {
    pub fn scm_from_double(val: f64) -> SCM;
}
extern "C" {
    pub fn scm_is_complex(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_make_rectangular(re: f64, im: f64) -> SCM;
}
extern "C" {
    pub fn scm_c_make_polar(mag: f64, ang: f64) -> SCM;
}
extern "C" {
    pub fn scm_c_real_part(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_c_imag_part(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_c_magnitude(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_c_angle(z: SCM) -> f64;
}
extern "C" {
    pub fn scm_is_number(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "scm_install_gmp_memory_functions"]
    pub static mut scm_install_gmp_memory_functions: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_numbers();
}
pub type scm_t_vector_ref =
    ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: usize)
                              -> SCM>;
pub type scm_t_vector_set =
    ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: usize,
                                               arg3: SCM)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_array_dim {
    pub lbnd: isize,
    pub ubnd: isize,
    pub inc: isize,
}
#[test]
fn bindgen_test_layout_scm_t_array_dim() {
    assert_eq!(::std::mem::size_of::<scm_t_array_dim>() , 24usize , concat ! (
               "Size of: " , stringify ! ( scm_t_array_dim ) ));
    assert_eq! (::std::mem::align_of::<scm_t_array_dim>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( scm_t_array_dim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_dim ) ) . lbnd as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_dim ) ,
                "::" , stringify ! ( lbnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_dim ) ) . ubnd as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_dim ) ,
                "::" , stringify ! ( ubnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_dim ) ) . inc as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_dim ) ,
                "::" , stringify ! ( inc ) ));
}
impl Clone for scm_t_array_dim {
    fn clone(&self) -> Self { *self }
}
pub const scm_t_array_element_type_SCM_ARRAY_ELEMENT_TYPE_LAST:
          scm_t_array_element_type =
    scm_t_array_element_type::SCM_ARRAY_ELEMENT_TYPE_C64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_array_element_type {
    SCM_ARRAY_ELEMENT_TYPE_SCM = 0,
    SCM_ARRAY_ELEMENT_TYPE_CHAR = 1,
    SCM_ARRAY_ELEMENT_TYPE_BIT = 2,
    SCM_ARRAY_ELEMENT_TYPE_VU8 = 3,
    SCM_ARRAY_ELEMENT_TYPE_U8 = 4,
    SCM_ARRAY_ELEMENT_TYPE_S8 = 5,
    SCM_ARRAY_ELEMENT_TYPE_U16 = 6,
    SCM_ARRAY_ELEMENT_TYPE_S16 = 7,
    SCM_ARRAY_ELEMENT_TYPE_U32 = 8,
    SCM_ARRAY_ELEMENT_TYPE_S32 = 9,
    SCM_ARRAY_ELEMENT_TYPE_U64 = 10,
    SCM_ARRAY_ELEMENT_TYPE_S64 = 11,
    SCM_ARRAY_ELEMENT_TYPE_F32 = 12,
    SCM_ARRAY_ELEMENT_TYPE_F64 = 13,
    SCM_ARRAY_ELEMENT_TYPE_C32 = 14,
    SCM_ARRAY_ELEMENT_TYPE_C64 = 15,
}
extern "C" {
    #[link_name = "scm_i_array_element_types"]
    pub static mut scm_i_array_element_types: [SCM; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_array_handle {
    pub array: SCM,
    pub base: usize,
    pub ndims: usize,
    pub dims: *mut scm_t_array_dim,
    pub dim0: scm_t_array_dim,
    pub element_type: scm_t_array_element_type,
    pub elements: *const ::std::os::raw::c_void,
    pub writable_elements: *mut ::std::os::raw::c_void,
    pub vector: SCM,
    pub vref: scm_t_vector_ref,
    pub vset: scm_t_vector_set,
}
#[test]
fn bindgen_test_layout_scm_t_array_handle() {
    assert_eq!(::std::mem::size_of::<scm_t_array_handle>() , 104usize , concat
               ! ( "Size of: " , stringify ! ( scm_t_array_handle ) ));
    assert_eq! (::std::mem::align_of::<scm_t_array_handle>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( scm_t_array_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . array as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . base as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . ndims as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( ndims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . dims as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( dims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . dim0 as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( dim0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . element_type as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( element_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . elements as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( elements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) .
                writable_elements as * const _ as usize } , 72usize , concat !
                (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( writable_elements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . vector as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . vref as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( vref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_array_handle ) ) . vset as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_array_handle ) ,
                "::" , stringify ! ( vset ) ));
}
impl Clone for scm_t_array_handle {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn scm_array_get_handle(array: SCM, h: *mut scm_t_array_handle);
}
extern "C" {
    pub fn scm_array_handle_pos(h: *mut scm_t_array_handle, indices: SCM)
     -> isize;
}
extern "C" {
    pub fn scm_array_handle_pos_1(h: *mut scm_t_array_handle, idx0: isize)
     -> isize;
}
extern "C" {
    pub fn scm_array_handle_pos_2(h: *mut scm_t_array_handle, idx0: isize,
                                  idx1: isize) -> isize;
}
extern "C" {
    pub fn scm_array_handle_element_type(h: *mut scm_t_array_handle) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_release(h: *mut scm_t_array_handle);
}
extern "C" {
    pub fn scm_array_handle_elements(h: *mut scm_t_array_handle)
     -> *const SCM;
}
extern "C" {
    pub fn scm_array_handle_writable_elements(h: *mut scm_t_array_handle)
     -> *mut SCM;
}
extern "C" {
    pub fn scm_init_array_handle();
}
extern "C" {
    pub fn scm_ra_matchp(ra0: SCM, ras: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_ramapc(cproc: *mut ::std::os::raw::c_void, data: SCM, ra0: SCM,
                      lra: SCM, what: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_array_fill_x(ra: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_copy_x(src: SCM, dst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_map_x(ra0: SCM, proc_: SCM, lra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_for_each(proc_: SCM, ra0: SCM, lra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_index_map_x(ra: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_equal_p(ra0: SCM, ra1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_slice_for_each(frank: SCM, op: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_slice_for_each_in_order(frank: SCM, op: SCM, args: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_i_array_rebase(a: SCM, base: usize) -> SCM;
}
extern "C" {
    pub fn scm_init_array_map();
}
extern "C" {
    /// Arrays
    pub fn scm_make_array(fill: SCM, bounds: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_typed_array(type_: SCM, fill: SCM, bounds: SCM) -> SCM;
}
extern "C" {
    pub fn scm_from_contiguous_typed_array(type_: SCM, bounds: SCM,
                                           bytes:
                                               *const ::std::os::raw::c_void,
                                           byte_len: usize) -> SCM;
}
extern "C" {
    pub fn scm_shared_array_root(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_shared_array_offset(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_shared_array_increments(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_shared_array(oldra: SCM, mapfunc: SCM, dims: SCM) -> SCM;
}
extern "C" {
    pub fn scm_transpose_array(ra: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_contents(ra: SCM, strict: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_slice(ra: SCM, indices: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_cell_ref(ra: SCM, indices: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_cell_set_x(ra: SCM, b: SCM, indices: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_array(ndim: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_typed_array(type_: SCM, ndim: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_array_rank(ra: SCM) -> usize;
}
extern "C" {
    pub fn scm_array_rank(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_array(ndim: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_i_print_array(array: SCM, port: SCM,
                             pstate: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_shap2ra(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_arrays();
}
extern "C" {
    pub fn scm_procedure_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_thunk_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_with_setter_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_procedure_with_setter(procedure: SCM, setter: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setter(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_procs();
}
pub type scm_t_catch_body =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void)
                              -> SCM>;
pub type scm_t_catch_handler =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void,
                                               tag: SCM, throw_args: SCM)
                              -> SCM>;
extern "C" {
    pub fn scm_i_make_catch_body_closure(body: scm_t_catch_body,
                                         body_data:
                                             *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_i_make_catch_handler_closure(h: scm_t_catch_handler,
                                            handler_data:
                                                *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_c_catch(tag: SCM, body: scm_t_catch_body,
                       body_data: *mut ::std::os::raw::c_void,
                       handler: scm_t_catch_handler,
                       handler_data: *mut ::std::os::raw::c_void,
                       pre_unwind_handler: scm_t_catch_handler,
                       pre_unwind_handler_data: *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_c_with_throw_handler(tag: SCM, body: scm_t_catch_body,
                                    body_data: *mut ::std::os::raw::c_void,
                                    handler: scm_t_catch_handler,
                                    handler_data: *mut ::std::os::raw::c_void,
                                    lazy_catch_p: ::std::os::raw::c_int)
     -> SCM;
}
extern "C" {
    pub fn scm_internal_catch(tag: SCM, body: scm_t_catch_body,
                              body_data: *mut ::std::os::raw::c_void,
                              handler: scm_t_catch_handler,
                              handler_data: *mut ::std::os::raw::c_void)
     -> SCM;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_body_thunk_data {
    pub tag: SCM,
    pub body_proc: SCM,
}
#[test]
fn bindgen_test_layout_scm_body_thunk_data() {
    assert_eq!(::std::mem::size_of::<scm_body_thunk_data>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( scm_body_thunk_data ) ));
    assert_eq! (::std::mem::align_of::<scm_body_thunk_data>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( scm_body_thunk_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_body_thunk_data ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_body_thunk_data ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_body_thunk_data ) ) . body_proc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_body_thunk_data ) ,
                "::" , stringify ! ( body_proc ) ));
}
impl Clone for scm_body_thunk_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn scm_body_thunk(arg1: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_proc(arg1: *mut ::std::os::raw::c_void, arg2: SCM,
                              arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_proc_catching_all(arg1: *mut ::std::os::raw::c_void,
                                           arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_message(arg1: *mut ::std::os::raw::c_void, arg2: SCM,
                                 arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_message_noexit(arg1: *mut ::std::os::raw::c_void,
                                        arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_handle_by_throw(arg1: *mut ::std::os::raw::c_void, arg2: SCM,
                               arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_exit_status(args: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_catch_with_pre_unwind_handler(tag: SCM, thunk: SCM,
                                             handler: SCM, lazy_handler: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_catch(tag: SCM, thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_with_throw_handler(tag: SCM, thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ithrow(key: SCM, args: SCM, no_return: ::std::os::raw::c_int)
     -> SCM;
}
extern "C" {
    pub fn scm_report_stack_overflow();
}
extern "C" {
    pub fn scm_report_out_of_memory();
}
extern "C" {
    pub fn scm_throw(key: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_throw();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_dynstack {
    pub base: *mut scm_t_bits,
    pub top: *mut scm_t_bits,
    pub limit: *mut scm_t_bits,
}
#[test]
fn bindgen_test_layout_scm_t_dynstack() {
    assert_eq!(::std::mem::size_of::<scm_t_dynstack>() , 24usize , concat ! (
               "Size of: " , stringify ! ( scm_t_dynstack ) ));
    assert_eq! (::std::mem::align_of::<scm_t_dynstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_dynstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_dynstack ) ) . base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_dynstack ) , "::"
                , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_dynstack ) ) . top as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_dynstack ) , "::"
                , stringify ! ( top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_dynstack ) ) . limit as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_dynstack ) , "::"
                , stringify ! ( limit ) ));
}
impl Clone for scm_t_dynstack {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_dynstack_item_type {
    SCM_DYNSTACK_TYPE_NONE = 0,
    SCM_DYNSTACK_TYPE_FRAME = 1,
    SCM_DYNSTACK_TYPE_UNWINDER = 2,
    SCM_DYNSTACK_TYPE_REWINDER = 3,
    SCM_DYNSTACK_TYPE_WITH_FLUID = 4,
    SCM_DYNSTACK_TYPE_PROMPT = 5,
    SCM_DYNSTACK_TYPE_DYNWIND = 6,
    SCM_DYNSTACK_TYPE_DYNAMIC_STATE = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_dynstack_frame_flags { SCM_F_DYNSTACK_FRAME_REWINDABLE = 16, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_dynstack_winder_flags { SCM_F_DYNSTACK_WINDER_EXPLICIT = 16, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_dynstack_prompt_flags {
    SCM_F_DYNSTACK_PROMPT_ESCAPE_ONLY = 16,
}
pub type scm_t_guard =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn scm_dynstack_push_frame(arg1: *mut scm_t_dynstack,
                                   arg2: scm_t_dynstack_frame_flags);
}
extern "C" {
    pub fn scm_dynstack_push_rewinder(arg1: *mut scm_t_dynstack,
                                      arg2: scm_t_dynstack_winder_flags,
                                      arg3: scm_t_guard,
                                      arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_dynstack_push_unwinder(arg1: *mut scm_t_dynstack,
                                      arg2: scm_t_dynstack_winder_flags,
                                      arg3: scm_t_guard,
                                      arg4: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_dynstack_push_fluid(arg1: *mut scm_t_dynstack, fluid: SCM,
                                   value: SCM,
                                   dynamic_state: *mut scm_t_dynamic_state);
}
extern "C" {
    pub fn scm_dynstack_push_dynamic_state(arg1: *mut scm_t_dynstack,
                                           arg2: SCM,
                                           arg3: *mut scm_t_dynamic_state);
}
extern "C" {
    pub fn scm_dynstack_push_prompt(arg1: *mut scm_t_dynstack,
                                    arg2: scm_t_dynstack_prompt_flags,
                                    key: SCM, fp_offset: scm_t_ptrdiff,
                                    sp_offset: scm_t_ptrdiff,
                                    ip: *mut scm_t_uint32,
                                    registers: *mut scm_i_jmp_buf);
}
extern "C" {
    pub fn scm_dynstack_push_dynwind(arg1: *mut scm_t_dynstack, enter: SCM,
                                     leave: SCM);
}
extern "C" {
    pub fn scm_dynstack_pop(arg1: *mut scm_t_dynstack);
}
extern "C" {
    pub fn scm_dynstack_capture_all(dynstack: *mut scm_t_dynstack)
     -> *mut scm_t_dynstack;
}
extern "C" {
    pub fn scm_dynstack_capture(dynstack: *mut scm_t_dynstack,
                                item: *mut scm_t_bits) -> *mut scm_t_dynstack;
}
extern "C" {
    pub fn scm_dynstack_wind_1(arg1: *mut scm_t_dynstack,
                               arg2: *mut scm_t_bits);
}
extern "C" {
    pub fn scm_dynstack_unwind_1(arg1: *mut scm_t_dynstack) -> scm_t_bits;
}
extern "C" {
    pub fn scm_dynstack_wind(arg1: *mut scm_t_dynstack,
                             arg2: *mut scm_t_bits);
}
extern "C" {
    pub fn scm_dynstack_unwind(arg1: *mut scm_t_dynstack,
                               arg2: *mut scm_t_bits);
}
extern "C" {
    pub fn scm_dynstack_unwind_fork(arg1: *mut scm_t_dynstack,
                                    arg2: *mut scm_t_dynstack)
     -> *mut scm_t_bits;
}
extern "C" {
    pub fn scm_dynstack_unwind_frame(arg1: *mut scm_t_dynstack);
}
extern "C" {
    pub fn scm_dynstack_unwind_fluid(dynstack: *mut scm_t_dynstack,
                                     dynamic_state: *mut scm_t_dynamic_state);
}
extern "C" {
    pub fn scm_dynstack_unwind_dynamic_state(dynstack: *mut scm_t_dynstack,
                                             dynamic_state:
                                                 *mut scm_t_dynamic_state);
}
extern "C" {
    pub fn scm_dynstack_find_prompt(arg1: *mut scm_t_dynstack, arg2: SCM,
                                    arg3: *mut scm_t_dynstack_prompt_flags,
                                    arg4: *mut scm_t_ptrdiff,
                                    arg5: *mut scm_t_ptrdiff,
                                    arg6: *mut *mut scm_t_uint32,
                                    arg7: *mut *mut scm_i_jmp_buf)
     -> *mut scm_t_bits;
}
extern "C" {
    pub fn scm_dynstack_find_old_fluid_value(arg1: *mut scm_t_dynstack,
                                             arg2: SCM, arg3: usize,
                                             arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynstack_relocate_prompts(arg1: *mut scm_t_dynstack,
                                         arg2: scm_t_ptrdiff);
}
extern "C" {
    pub fn scm_dynstack_wind_prompt(arg1: *mut scm_t_dynstack,
                                    arg2: *mut scm_t_bits,
                                    arg3: scm_t_ptrdiff,
                                    arg4: *mut scm_i_jmp_buf);
}
extern "C" {
    #[link_name = "pselect$1050"]
    pub fn pselect(arg1: ::std::os::raw::c_int, arg2: *mut fd_set,
                   arg3: *mut fd_set, arg4: *mut fd_set,
                   arg5: *const timespec, arg6: *const sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_std_select(fds: ::std::os::raw::c_int, rfds: *mut fd_set,
                          wfds: *mut fd_set, efds: *mut fd_set,
                          timeout: *mut timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct scm_t_contregs {
    pub jmpbuf: scm_i_jmp_buf,
    pub num_stack_items: usize,
    pub root: SCM,
    pub vp: *mut scm_vm,
    pub vm_cont: SCM,
    pub offset: scm_t_ptrdiff,
    pub stack: [SCM_STACKITEM; 1usize],
}
#[test]
fn bindgen_test_layout_scm_t_contregs() {
    assert_eq!(::std::mem::size_of::<scm_t_contregs>() , 200usize , concat ! (
               "Size of: " , stringify ! ( scm_t_contregs ) ));
    assert_eq! (::std::mem::align_of::<scm_t_contregs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_contregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_contregs ) ) . jmpbuf as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_contregs ) , "::"
                , stringify ! ( jmpbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_contregs ) ) . num_stack_items as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_contregs ) , "::"
                , stringify ! ( num_stack_items ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_contregs ) ) . root as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_contregs ) , "::"
                , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_contregs ) ) . vp as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_contregs ) , "::"
                , stringify ! ( vp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_contregs ) ) . vm_cont as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_contregs ) , "::"
                , stringify ! ( vm_cont ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_contregs ) ) . offset as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_contregs ) , "::"
                , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_contregs ) ) . stack as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_contregs ) , "::"
                , stringify ! ( stack ) ));
}
extern "C" {
    pub fn scm_i_make_continuation(first: *mut ::std::os::raw::c_int,
                                   vp: *mut scm_vm, vm_cont: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_check_continuation(cont: SCM);
}
extern "C" {
    pub fn scm_i_reinstate_continuation(cont: SCM);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_frame {
    _unused: [u8; 0],
}
extern "C" {
    pub fn scm_i_continuation_to_frame(cont: SCM, frame: *mut scm_frame)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_contregs_vp(contregs: SCM) -> *mut scm_vm;
}
extern "C" {
    pub fn scm_i_contregs_vm_cont(contregs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_with_continuation_barrier(func:
                                               ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                              *mut ::std::os::raw::c_void)
                                                                         ->
                                                                             *mut ::std::os::raw::c_void>,
                                           arg1: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_with_continuation_barrier(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_with_continuation_barrier(body: scm_t_catch_body,
                                           body_data:
                                               *mut ::std::os::raw::c_void,
                                           handler: scm_t_catch_handler,
                                           handler_data:
                                               *mut ::std::os::raw::c_void,
                                           pre_unwind_handler:
                                               scm_t_catch_handler,
                                           pre_unwind_handler_data:
                                               *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_init_continuations();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(::std::mem::size_of::<sched_param>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sched_param ) ));
    assert_eq! (::std::mem::align_of::<sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sched_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sched_param ) ) . sched_priority as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sched_param ) , "::" ,
                stringify ! ( sched_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sched_param ) ) . __opaque as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sched_param ) , "::" ,
                stringify ! ( __opaque ) ));
}
impl Clone for sched_param {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_2 =
    _bindgen_ty_2::QOS_CLASS_USER_INTERACTIVE;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_2 =
    _bindgen_ty_2::QOS_CLASS_USER_INITIATED;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_2 = _bindgen_ty_2::QOS_CLASS_DEFAULT;
pub const QOS_CLASS_UTILITY: _bindgen_ty_2 = _bindgen_ty_2::QOS_CLASS_UTILITY;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_2 =
    _bindgen_ty_2::QOS_CLASS_BACKGROUND;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_2 =
    _bindgen_ty_2::QOS_CLASS_UNSPECIFIED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    QOS_CLASS_USER_INTERACTIVE = 33,
    QOS_CLASS_USER_INITIATED = 25,
    QOS_CLASS_DEFAULT = 21,
    QOS_CLASS_UTILITY = 17,
    QOS_CLASS_BACKGROUND = 9,
    QOS_CLASS_UNSPECIFIED = 0,
}
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    pub fn pthread_attr_set_qos_class_np(__attr: *mut pthread_attr_t,
                                         __qos_class: qos_class_t,
                                         __relative_priority:
                                             ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_get_qos_class_np(__attr: *mut pthread_attr_t,
                                         __qos_class: *mut qos_class_t,
                                         __relative_priority:
                                             *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_qos_class_self_np(__qos_class: qos_class_t,
                                         __relative_priority:
                                             ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_get_qos_class_np(__pthread: pthread_t,
                                    __qos_class: *mut qos_class_t,
                                    __relative_priority:
                                        *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    pub fn pthread_override_qos_class_start_np(__pthread: pthread_t,
                                               __qos_class: qos_class_t,
                                               __relative_priority:
                                                   ::std::os::raw::c_int)
     -> pthread_override_t;
}
extern "C" {
    pub fn pthread_override_qos_class_end_np(__override: pthread_override_t)
     -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    pub fn pthread_atfork(arg1: ::std::option::Option<unsafe extern "C" fn()>,
                          arg2: ::std::option::Option<unsafe extern "C" fn()>,
                          arg3: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(arg1: *const pthread_attr_t,
                                       arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(arg1: *const pthread_attr_t,
                                     arg2: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(arg1: *const pthread_attr_t,
                                        arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(arg1: *const pthread_attr_t,
                                      arg2: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(arg1: *const pthread_attr_t,
                                       arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(arg1: *const pthread_attr_t,
                                 arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(arg1: *const pthread_attr_t,
                                 arg2: *mut *mut ::std::os::raw::c_void,
                                 arg3: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(arg1: *const pthread_attr_t,
                                     arg2: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(arg1: *const pthread_attr_t,
                                     arg2: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(arg1: *mut pthread_attr_t,
                                       arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(arg1: *mut pthread_attr_t, arg2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(arg1: *mut pthread_attr_t,
                                        arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(arg1: *mut pthread_attr_t,
                                      arg2: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(arg1: *mut pthread_attr_t,
                                       arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(arg1: *mut pthread_attr_t,
                                 arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(arg1: *mut pthread_attr_t,
                                 arg2: *mut ::std::os::raw::c_void,
                                 arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(arg1: *mut pthread_attr_t,
                                     arg2: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(arg1: *mut pthread_attr_t, arg2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(arg1: *mut pthread_cond_t,
                             arg2: *const pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(arg1: *mut pthread_cond_t,
                                  arg2: *mut pthread_mutex_t,
                                  arg3: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(arg1: *mut pthread_cond_t,
                             arg2: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(arg1: *const pthread_condattr_t,
                                       arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(arg1: *mut pthread_condattr_t,
                                       arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(arg1: *mut pthread_t, arg2: *const pthread_attr_t,
                          arg3:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::std::os::raw::c_void)
                                                        ->
                                                            *mut ::std::os::raw::c_void>,
                          arg4: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(arg1: pthread_t,
                                 arg2: *mut ::std::os::raw::c_int,
                                 arg3: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_join(arg1: pthread_t,
                        arg2: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(arg1: *mut pthread_key_t,
                              arg2:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(arg1: *const pthread_mutex_t,
                                        arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(arg1: *mut pthread_mutex_t,
                              arg2: *const pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(arg1: *mut pthread_mutex_t,
                                        arg2: ::std::os::raw::c_int,
                                        arg3: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(arg1: *const pthread_mutexattr_t,
                                            arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(arg1: *const pthread_mutexattr_t,
                                         arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(arg1: *const pthread_mutexattr_t,
                                        arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(arg1: *const pthread_mutexattr_t,
                                     arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(arg1: *mut pthread_mutexattr_t,
                                            arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(arg1: *mut pthread_mutexattr_t,
                                         arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(arg1: *mut pthread_mutexattr_t,
                                        arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(arg1: *mut pthread_mutexattr_t,
                                     arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(arg1: *mut pthread_once_t,
                        arg2: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(arg1: *mut pthread_rwlock_t,
                               arg2: *const pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(arg1: *const pthread_rwlockattr_t,
                                         arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(arg1: *mut pthread_rwlockattr_t,
                                         arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_setcancelstate(arg1: ::std::os::raw::c_int,
                                  arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(arg1: ::std::os::raw::c_int,
                                 arg2: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(arg1: pthread_t, arg2: ::std::os::raw::c_int,
                                 arg3: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(arg1: pthread_key_t,
                               arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(arg1: pthread_t,
                              arg2: *mut ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> usize;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_cond_signal_thread_np(arg1: *mut pthread_cond_t,
                                         arg2: pthread_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(arg1: *mut pthread_cond_t,
                                              arg2: *mut pthread_mutex_t,
                                              arg3: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_suspended_np(arg1: *mut pthread_t,
                                       arg2: *const pthread_attr_t,
                                       arg3:
                                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                          *mut ::std::os::raw::c_void)
                                                                     ->
                                                                         *mut ::std::os::raw::c_void>,
                                       arg4: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    pub fn pthread_sigmask(arg1: ::std::os::raw::c_int, arg2: *const sigset_t,
                           arg3: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield_np();
}
extern "C" {
    #[link_name = "scm_i_pthread_mutexattr_recursive"]
    pub static mut scm_i_pthread_mutexattr_recursive:
               [pthread_mutexattr_t; 1usize];
}
extern "C" {
    #[link_name = "scm_tc16_thread"]
    pub static mut scm_tc16_thread: scm_t_bits;
}
extern "C" {
    #[link_name = "scm_tc16_mutex"]
    pub static mut scm_tc16_mutex: scm_t_bits;
}
extern "C" {
    #[link_name = "scm_tc16_condvar"]
    pub static mut scm_tc16_condvar: scm_t_bits;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_thread_wake_data {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct scm_i_thread {
    pub next_thread: *mut scm_i_thread,
    pub handle: SCM,
    pub pthread: pthread_t,
    pub result: SCM,
    pub exited: ::std::os::raw::c_int,
    pub guile_mode: ::std::os::raw::c_int,
    pub needs_unregister: ::std::os::raw::c_int,
    pub wake: *mut scm_thread_wake_data,
    pub sleep_cond: pthread_cond_t,
    pub sleep_pipe: [::std::os::raw::c_int; 2usize],
    pub freelists: *mut *mut ::std::os::raw::c_void,
    pub pointerless_freelists: *mut *mut ::std::os::raw::c_void,
    pub dynamic_state: *mut scm_t_dynamic_state,
    pub dynstack: scm_t_dynstack,
    pub pending_asyncs: SCM,
    pub block_asyncs: ::std::os::raw::c_uint,
    pub continuation_root: SCM,
    pub continuation_base: *mut SCM_STACKITEM,
    pub vp: *mut scm_vm,
    pub base: *mut SCM_STACKITEM,
    pub regs: scm_i_jmp_buf,
}
#[test]
fn bindgen_test_layout_scm_i_thread() {
    assert_eq!(::std::mem::size_of::<scm_i_thread>() , 360usize , concat ! (
               "Size of: " , stringify ! ( scm_i_thread ) ));
    assert_eq! (::std::mem::align_of::<scm_i_thread>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_i_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . next_thread as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( next_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . handle as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . pthread as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( pthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . result as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . exited as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( exited ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . guile_mode as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( guile_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . needs_unregister as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( needs_unregister ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . wake as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( wake ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . sleep_cond as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( sleep_cond ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . sleep_pipe as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( sleep_pipe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . freelists as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( freelists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . pointerless_freelists
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( pointerless_freelists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . dynamic_state as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( dynamic_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . dynstack as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( dynstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . pending_asyncs as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( pending_asyncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . block_asyncs as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( block_asyncs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . continuation_root as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( continuation_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . continuation_base as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( continuation_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . vp as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( vp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . base as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_i_thread ) ) . regs as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_i_thread ) , "::" ,
                stringify ! ( regs ) ));
}
extern "C" {
    pub fn scm_spawn_thread(body: scm_t_catch_body,
                            body_data: *mut ::std::os::raw::c_void,
                            handler: scm_t_catch_handler,
                            handler_data: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_without_guile(func:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void)
                                                           ->
                                                               *mut ::std::os::raw::c_void>,
                             data: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_with_guile(func:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::std::os::raw::c_void)
                                                        ->
                                                            *mut ::std::os::raw::c_void>,
                          data: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_threads_prehistory(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_init_threads();
}
extern "C" {
    pub fn scm_init_threads_default_dynamic_state();
}
extern "C" {
    pub fn scm_i_dynwind_pthread_mutex_lock_block_asyncs(mutex:
                                                             *mut pthread_mutex_t);
}
extern "C" {
    pub fn scm_call_with_new_thread(thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_yield() -> SCM;
}
extern "C" {
    pub fn scm_cancel_thread(t: SCM) -> SCM;
}
extern "C" {
    pub fn scm_join_thread(t: SCM) -> SCM;
}
extern "C" {
    pub fn scm_join_thread_timed(t: SCM, timeout: SCM, timeoutval: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_thread_p(t: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_mutex() -> SCM;
}
extern "C" {
    pub fn scm_make_recursive_mutex() -> SCM;
}
extern "C" {
    pub fn scm_make_mutex_with_kind(kind: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lock_mutex(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_timed_lock_mutex(m: SCM, timeout: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_lock_mutex(mutex: SCM);
}
extern "C" {
    pub fn scm_try_mutex(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unlock_mutex(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mutex_p(o: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mutex_locked_p(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mutex_owner(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mutex_level(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_condition_variable() -> SCM;
}
extern "C" {
    pub fn scm_wait_condition_variable(cond: SCM, mutex: SCM) -> SCM;
}
extern "C" {
    pub fn scm_timed_wait_condition_variable(cond: SCM, mutex: SCM,
                                             abstime: SCM) -> SCM;
}
extern "C" {
    pub fn scm_signal_condition_variable(cond: SCM) -> SCM;
}
extern "C" {
    pub fn scm_broadcast_condition_variable(cond: SCM) -> SCM;
}
extern "C" {
    pub fn scm_condition_variable_p(o: SCM) -> SCM;
}
extern "C" {
    pub fn scm_current_thread() -> SCM;
}
extern "C" {
    pub fn scm_all_threads() -> SCM;
}
extern "C" {
    pub fn scm_c_thread_exited_p(thread: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_thread_exited_p(thread: SCM) -> SCM;
}
extern "C" {
    #[link_name = "scm_i_misc_mutex"]
    pub static mut scm_i_misc_mutex: pthread_mutex_t;
}
extern "C" {
    pub fn scm_pthread_mutex_lock(mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_dynwind_pthread_mutex_lock(mutex: *mut pthread_mutex_t);
}
extern "C" {
    pub fn scm_pthread_cond_wait(cond: *mut pthread_cond_t,
                                 mutex: *mut pthread_mutex_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_pthread_cond_timedwait(cond: *mut pthread_cond_t,
                                      mutex: *mut pthread_mutex_t,
                                      abstime: *const scm_t_timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_std_sleep(arg1: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn scm_std_usleep(arg1: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_total_processor_count() -> SCM;
}
extern "C" {
    pub fn scm_current_processor_count() -> SCM;
}
extern "C" {
    pub fn scm_async_tick();
}
extern "C" {
    pub fn scm_switch();
}
extern "C" {
    pub fn scm_system_async_mark(a: SCM) -> SCM;
}
extern "C" {
    pub fn scm_system_async_mark_for_thread(a: SCM, thread: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_prepare_to_wait_on_fd(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_prepare_to_wait_on_cond(m: *mut pthread_mutex_t,
                                         c: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_wait_finished();
}
extern "C" {
    pub fn scm_noop(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_blocked_asyncs(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_unblocked_asyncs(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_call_with_blocked_asyncs(p:
                                              ::std::option::Option<unsafe extern "C" fn(d:
                                                                                             *mut ::std::os::raw::c_void)
                                                                        ->
                                                                            *mut ::std::os::raw::c_void>,
                                          d: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_c_call_with_unblocked_asyncs(p:
                                                ::std::option::Option<unsafe extern "C" fn(d:
                                                                                               *mut ::std::os::raw::c_void)
                                                                          ->
                                                                              *mut ::std::os::raw::c_void>,
                                            d: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_dynwind_block_asyncs();
}
extern "C" {
    pub fn scm_dynwind_unblock_asyncs();
}
extern "C" {
    pub fn scm_i_prepare_to_wait(arg1: *mut scm_i_thread,
                                 arg2: *mut scm_thread_wake_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_wait_finished(arg1: *mut scm_i_thread);
}
extern "C" {
    pub fn scm_i_prepare_to_wait_on_fd(arg1: *mut scm_i_thread,
                                       arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_prepare_to_wait_on_cond(arg1: *mut scm_i_thread,
                                         arg2: *mut pthread_mutex_t,
                                         arg3: *mut pthread_cond_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_async_push(t: *mut scm_i_thread, proc_: SCM);
}
extern "C" {
    pub fn scm_i_async_pop(t: *mut scm_i_thread) -> SCM;
}
extern "C" {
    pub fn scm_init_async();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_c_hook_type {
    SCM_C_HOOK_NORMAL = 0,
    SCM_C_HOOK_OR = 1,
    SCM_C_HOOK_AND = 2,
}
pub type scm_t_c_hook_function =
    ::std::option::Option<unsafe extern "C" fn(hook_data:
                                                   *mut ::std::os::raw::c_void,
                                               fn_data:
                                                   *mut ::std::os::raw::c_void,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_c_hook_entry {
    pub next: *mut scm_t_c_hook_entry,
    pub func: scm_t_c_hook_function,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_scm_t_c_hook_entry() {
    assert_eq!(::std::mem::size_of::<scm_t_c_hook_entry>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( scm_t_c_hook_entry ) ));
    assert_eq! (::std::mem::align_of::<scm_t_c_hook_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( scm_t_c_hook_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_c_hook_entry ) ) . next as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_c_hook_entry ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_c_hook_entry ) ) . func as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_c_hook_entry ) ,
                "::" , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_c_hook_entry ) ) . data as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_c_hook_entry ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for scm_t_c_hook_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_c_hook {
    pub first: *mut scm_t_c_hook_entry,
    pub type_: scm_t_c_hook_type,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_scm_t_c_hook() {
    assert_eq!(::std::mem::size_of::<scm_t_c_hook>() , 24usize , concat ! (
               "Size of: " , stringify ! ( scm_t_c_hook ) ));
    assert_eq! (::std::mem::align_of::<scm_t_c_hook>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_c_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_c_hook ) ) . first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_c_hook ) , "::" ,
                stringify ! ( first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_c_hook ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_c_hook ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_c_hook ) ) . data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_c_hook ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for scm_t_c_hook {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn scm_c_hook_init(hook: *mut scm_t_c_hook,
                           hook_data: *mut ::std::os::raw::c_void,
                           type_: scm_t_c_hook_type);
}
extern "C" {
    pub fn scm_c_hook_add(hook: *mut scm_t_c_hook,
                          func: scm_t_c_hook_function,
                          fn_data: *mut ::std::os::raw::c_void,
                          appendp: ::std::os::raw::c_int);
}
extern "C" {
    pub fn scm_c_hook_remove(hook: *mut scm_t_c_hook,
                             func: scm_t_c_hook_function,
                             fn_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_c_hook_run(hook: *mut scm_t_c_hook,
                          data: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "scm_tc16_hook"]
    pub static mut scm_tc16_hook: scm_t_bits;
}
extern "C" {
    pub fn scm_make_hook(n_args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hook_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hook_empty_p(hook: SCM) -> SCM;
}
extern "C" {
    pub fn scm_add_hook_x(hook: SCM, thunk: SCM, appendp: SCM) -> SCM;
}
extern "C" {
    pub fn scm_remove_hook_x(hook: SCM, thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reset_hook_x(hook: SCM) -> SCM;
}
extern "C" {
    pub fn scm_run_hook(hook: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_run_hook(hook: SCM, args: SCM);
}
extern "C" {
    pub fn scm_c_run_hookn(hook: SCM, argv: *mut SCM, nargs: usize);
}
extern "C" {
    pub fn scm_hook_to_list(hook: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_hooks();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_cell {
    pub word_0: SCM,
    pub word_1: SCM,
}
#[test]
fn bindgen_test_layout_scm_t_cell() {
    assert_eq!(::std::mem::size_of::<scm_t_cell>() , 16usize , concat ! (
               "Size of: " , stringify ! ( scm_t_cell ) ));
    assert_eq! (::std::mem::align_of::<scm_t_cell>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_cell ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_cell ) ) . word_0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_cell ) , "::" ,
                stringify ! ( word_0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_cell ) ) . word_1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_cell ) , "::" ,
                stringify ! ( word_1 ) ));
}
impl Clone for scm_t_cell {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "scm_i_gc_admin_mutex"]
    pub static mut scm_i_gc_admin_mutex: pthread_mutex_t;
}
extern "C" {
    #[link_name = "scm_i_sweep_mutex"]
    pub static mut scm_i_sweep_mutex: pthread_mutex_t;
}
extern "C" {
    #[link_name = "scm_gc_ports_collected"]
    pub static mut scm_gc_ports_collected: ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "scm_after_gc_hook"]
    pub static mut scm_after_gc_hook: SCM;
}
extern "C" {
    #[link_name = "scm_before_gc_c_hook"]
    pub static mut scm_before_gc_c_hook: scm_t_c_hook;
}
extern "C" {
    #[link_name = "scm_before_mark_c_hook"]
    pub static mut scm_before_mark_c_hook: scm_t_c_hook;
}
extern "C" {
    #[link_name = "scm_before_sweep_c_hook"]
    pub static mut scm_before_sweep_c_hook: scm_t_c_hook;
}
extern "C" {
    #[link_name = "scm_after_sweep_c_hook"]
    pub static mut scm_after_sweep_c_hook: scm_t_c_hook;
}
extern "C" {
    #[link_name = "scm_after_gc_c_hook"]
    pub static mut scm_after_gc_c_hook: scm_t_c_hook;
}
extern "C" {
    pub fn scm_set_debug_cell_accesses_x(flag: SCM) -> SCM;
}
extern "C" {
    pub fn scm_object_address(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gc_enable() -> SCM;
}
extern "C" {
    pub fn scm_gc_disable() -> SCM;
}
extern "C" {
    pub fn scm_gc_dump() -> SCM;
}
extern "C" {
    pub fn scm_gc_stats() -> SCM;
}
extern "C" {
    pub fn scm_gc() -> SCM;
}
extern "C" {
    pub fn scm_i_gc(what: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_gc_mark(p: SCM);
}
extern "C" {
    pub fn scm_gc_sweep();
}
extern "C" {
    pub fn scm_gc_register_allocation(size: usize);
}
extern "C" {
    pub fn scm_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_calloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_realloc(mem: *mut ::std::os::raw::c_void, size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_strdup(str: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_strndup(str: *const ::std::os::raw::c_char, n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_gc_register_collectable_memory(mem:
                                                  *mut ::std::os::raw::c_void,
                                              size: usize,
                                              what:
                                                  *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_gc_unregister_collectable_memory(mem:
                                                    *mut ::std::os::raw::c_void,
                                                size: usize,
                                                what:
                                                    *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_gc_malloc_pointerless(size: usize,
                                     what: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_gc_calloc(size: usize, what: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_gc_malloc(size: usize, what: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_gc_realloc(mem: *mut ::std::os::raw::c_void, old_size: usize,
                          new_size: usize,
                          what: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_gc_free(mem: *mut ::std::os::raw::c_void, size: usize,
                       what: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_gc_strdup(str: *const ::std::os::raw::c_char,
                         what: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_gc_strndup(str: *const ::std::os::raw::c_char, n: usize,
                          what: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_remember_upto_here_1(obj: SCM);
}
extern "C" {
    pub fn scm_remember_upto_here_2(obj1: SCM, obj2: SCM);
}
extern "C" {
    pub fn scm_remember_upto_here(obj1: SCM, ...);
}
extern "C" {
    pub fn scm_return_first(elt: SCM, ...) -> SCM;
}
extern "C" {
    pub fn scm_return_first_int(x: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_permanent_object(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gc_protect_object(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gc_unprotect_object(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gc_register_root(p: *mut SCM);
}
extern "C" {
    pub fn scm_gc_unregister_root(p: *mut SCM);
}
extern "C" {
    pub fn scm_gc_register_roots(b: *mut SCM, n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn scm_gc_unregister_roots(b: *mut SCM, n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn scm_gc_after_nonlocal_exit();
}
extern "C" {
    pub fn scm_storage_prehistory();
}
extern "C" {
    pub fn scm_init_gc_protect_object();
}
extern "C" {
    pub fn scm_init_gc();
}
extern "C" {
    pub fn scm_is_bool(arg1: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_to_bool(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_not(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_boolean_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_nil_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_boolean();
}
extern "C" {
    /// Bit vectors
    pub fn scm_bitvector_p(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector(bits: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_bitvector(len: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_length(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_ref(vec: SCM, idx: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_set_x(vec: SCM, idx: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_bitvector(list: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_to_list(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bitvector_fill_x(vec: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_count(item: SCM, seq: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_position(item: SCM, v: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_set_star_x(v: SCM, kv: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_count_star(v: SCM, kv: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bit_invert_x(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_istr2bve(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_bitvector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_make_bitvector(len: usize, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_bitvector_length(vec: SCM) -> usize;
}
extern "C" {
    pub fn scm_c_bitvector_ref(vec: SCM, idx: usize) -> SCM;
}
extern "C" {
    pub fn scm_c_bitvector_set_x(vec: SCM, idx: usize, val: SCM);
}
extern "C" {
    pub fn scm_array_handle_bit_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_uint32;
}
extern "C" {
    pub fn scm_array_handle_bit_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_array_handle_bit_elements_offset(h: *mut scm_t_array_handle)
     -> usize;
}
extern "C" {
    pub fn scm_bitvector_elements(vec: SCM, h: *mut scm_t_array_handle,
                                  offp: *mut usize, lenp: *mut usize,
                                  incp: *mut isize) -> *const scm_t_uint32;
}
extern "C" {
    pub fn scm_bitvector_writable_elements(vec: SCM,
                                           h: *mut scm_t_array_handle,
                                           offp: *mut usize, lenp: *mut usize,
                                           incp: *mut isize)
     -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_i_bitvector_bits(vec: SCM) -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_i_is_mutable_bitvector(vec: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_print_bitvector(vec: SCM, port: SCM,
                                 pstate: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_bitvector_equal_p(vec1: SCM, vec2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_bitvectors();
}
extern "C" {
    #[link_name = "scm_endianness_big"]
    pub static mut scm_endianness_big: SCM;
}
extern "C" {
    #[link_name = "scm_endianness_little"]
    pub static mut scm_endianness_little: SCM;
}
extern "C" {
    pub fn scm_c_make_bytevector(arg1: usize) -> SCM;
}
extern "C" {
    pub fn scm_is_bytevector(arg1: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_bytevector_length(arg1: SCM) -> usize;
}
extern "C" {
    pub fn scm_c_bytevector_ref(arg1: SCM, arg2: usize) -> scm_t_uint8;
}
extern "C" {
    pub fn scm_c_bytevector_set_x(arg1: SCM, arg2: usize, arg3: scm_t_uint8);
}
extern "C" {
    pub fn scm_make_bytevector(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_native_endianness() -> SCM;
}
extern "C" {
    pub fn scm_bytevector_p(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_length(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_eq_p(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_fill_x(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_copy_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM,
                                 arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_copy(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uniform_array_to_bytevector(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_to_u8_list(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8_list_to_bytevector(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_uint_list_to_bytevector(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_to_uint_list(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_sint_list_to_bytevector(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_to_sint_list(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u16_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s16_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u32_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s32_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u64_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s64_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u8_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s8_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_uint_ref(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_sint_ref(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u16_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s16_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u32_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s32_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u64_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s64_ref(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u16_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s16_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u32_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s32_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u64_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s64_native_set_x(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u8_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s8_set_x(arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_uint_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                     arg4: SCM, arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_sint_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                     arg4: SCM, arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u16_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                    arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s16_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                    arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u32_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                    arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s32_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                    arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_u64_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                    arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_s64_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                    arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_single_ref(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_single_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_single_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                            arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_single_native_set_x(arg1: SCM, arg2: SCM,
                                                   arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_double_ref(arg1: SCM, arg2: SCM, arg3: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_double_native_ref(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_double_set_x(arg1: SCM, arg2: SCM, arg3: SCM,
                                            arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_ieee_double_native_set_x(arg1: SCM, arg2: SCM,
                                                   arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_utf8(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_utf16(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_utf32(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_utf8_to_string(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_utf16_to_string(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_utf32_to_string(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_typed_bytevector(arg1: usize,
                                       arg2: scm_t_array_element_type) -> SCM;
}
extern "C" {
    pub fn scm_c_take_typed_bytevector(arg1: *mut ::std::os::raw::c_schar,
                                       arg2: usize,
                                       arg3: scm_t_array_element_type,
                                       arg4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bootstrap_bytevectors();
}
extern "C" {
    pub fn scm_init_bytevectors();
}
extern "C" {
    #[link_name = "scm_i_native_endianness"]
    pub static mut scm_i_native_endianness: SCM;
}
extern "C" {
    pub fn scm_c_take_gc_bytevector(arg1: *mut ::std::os::raw::c_schar,
                                    arg2: usize, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_print_bytevector(arg1: SCM, arg2: SCM,
                                  arg3: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_shrink_bytevector(arg1: SCM, arg2: usize) -> SCM;
}
extern "C" {
    pub fn scm_i_bytevector_generalized_set_x(arg1: SCM, arg2: usize,
                                              arg3: SCM);
}
extern "C" {
    #[link_name = "scm_null_bytevector"]
    pub static mut scm_null_bytevector: SCM;
}
extern "C" {
    pub fn scm_dynamic_link(fname: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_unlink(dobj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_object_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_pointer(name: SCM, dobj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_func(symb: SCM, dobj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_call(symb: SCM, dobj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_dynamic_linking();
}
extern "C" {
    pub fn scm_dynamic_wind(thunk1: SCM, thunk2: SCM, thunk3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_dynwind();
}
extern "C" {
    pub fn scm_swap_bindings(vars: SCM, vals: SCM);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_dynwind_flags { SCM_F_DYNWIND_REWINDABLE = 16, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_wind_flags { SCM_F_WIND_EXPLICITLY = 16, }
extern "C" {
    pub fn scm_dynwind_begin(arg1: scm_t_dynwind_flags);
}
extern "C" {
    pub fn scm_dynwind_end();
}
extern "C" {
    pub fn scm_dynwind_unwind_handler(func:
                                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         *mut ::std::os::raw::c_void)>,
                                      data: *mut ::std::os::raw::c_void,
                                      arg1: scm_t_wind_flags);
}
extern "C" {
    pub fn scm_dynwind_rewind_handler(func:
                                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         *mut ::std::os::raw::c_void)>,
                                      data: *mut ::std::os::raw::c_void,
                                      arg1: scm_t_wind_flags);
}
extern "C" {
    pub fn scm_dynwind_unwind_handler_with_scm(func:
                                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                  SCM)>,
                                               data: SCM,
                                               arg1: scm_t_wind_flags);
}
extern "C" {
    pub fn scm_dynwind_rewind_handler_with_scm(func:
                                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                  SCM)>,
                                               data: SCM,
                                               arg1: scm_t_wind_flags);
}
extern "C" {
    pub fn scm_dynwind_free(mem: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_eq_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eqv_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_equal_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_eq();
}
pub type scm_t_struct_finalize =
    ::std::option::Option<unsafe extern "C" fn(obj: SCM)>;
extern "C" {
    #[link_name = "scm_standard_vtable_vtable"]
    pub static mut scm_standard_vtable_vtable: SCM;
}
extern "C" {
    #[link_name = "scm_applicable_struct_vtable_vtable"]
    pub static mut scm_applicable_struct_vtable_vtable: SCM;
}
extern "C" {
    #[link_name = "scm_applicable_struct_with_setter_vtable_vtable"]
    pub static mut scm_applicable_struct_with_setter_vtable_vtable: SCM;
}
extern "C" {
    pub fn scm_make_struct_layout(fields: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_vtable_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_allocate_struct(vtable: SCM, n_words: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_struct(vtable: SCM, tail_array_size: SCM, init: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_c_make_struct(vtable: SCM, n_tail: usize, n_inits: usize,
                             init: scm_t_bits, ...) -> SCM;
}
extern "C" {
    pub fn scm_c_make_structv(vtable: SCM, n_tail: usize, n_inits: usize,
                              init: *mut scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_make_vtable(fields: SCM, printer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_vtable_vtable(fields: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_ref(handle: SCM, pos: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_set_x(handle: SCM, pos: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_vtable(handle: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_vtable_name(vtable: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_struct_vtable_name_x(vtable: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_print_struct(exp: SCM, port: SCM, arg1: *mut scm_print_state);
}
extern "C" {
    pub fn scm_i_struct_equalp(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_struct_ihashq(arg1: SCM, arg2: ::std::os::raw::c_ulong,
                             arg3: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_alloc_struct(vtable_data: *mut scm_t_bits,
                              n_words: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_i_struct_inherit_vtable_magic(vtable: SCM, obj: SCM);
}
extern "C" {
    pub fn scm_init_struct();
}
extern "C" {
    #[link_name = "scm_sym_and"]
    pub static mut scm_sym_and: SCM;
}
extern "C" {
    #[link_name = "scm_sym_begin"]
    pub static mut scm_sym_begin: SCM;
}
extern "C" {
    #[link_name = "scm_sym_case"]
    pub static mut scm_sym_case: SCM;
}
extern "C" {
    #[link_name = "scm_sym_cond"]
    pub static mut scm_sym_cond: SCM;
}
extern "C" {
    #[link_name = "scm_sym_define"]
    pub static mut scm_sym_define: SCM;
}
extern "C" {
    #[link_name = "scm_sym_do"]
    pub static mut scm_sym_do: SCM;
}
extern "C" {
    #[link_name = "scm_sym_if"]
    pub static mut scm_sym_if: SCM;
}
extern "C" {
    #[link_name = "scm_sym_lambda"]
    pub static mut scm_sym_lambda: SCM;
}
extern "C" {
    #[link_name = "scm_sym_let"]
    pub static mut scm_sym_let: SCM;
}
extern "C" {
    #[link_name = "scm_sym_letstar"]
    pub static mut scm_sym_letstar: SCM;
}
extern "C" {
    #[link_name = "scm_sym_letrec"]
    pub static mut scm_sym_letrec: SCM;
}
extern "C" {
    #[link_name = "scm_sym_quote"]
    pub static mut scm_sym_quote: SCM;
}
extern "C" {
    #[link_name = "scm_sym_quasiquote"]
    pub static mut scm_sym_quasiquote: SCM;
}
extern "C" {
    #[link_name = "scm_sym_unquote"]
    pub static mut scm_sym_unquote: SCM;
}
extern "C" {
    #[link_name = "scm_sym_uq_splicing"]
    pub static mut scm_sym_uq_splicing: SCM;
}
extern "C" {
    #[link_name = "scm_sym_at"]
    pub static mut scm_sym_at: SCM;
}
extern "C" {
    #[link_name = "scm_sym_atat"]
    pub static mut scm_sym_atat: SCM;
}
extern "C" {
    #[link_name = "scm_sym_delay"]
    pub static mut scm_sym_delay: SCM;
}
extern "C" {
    #[link_name = "scm_sym_eval_when"]
    pub static mut scm_sym_eval_when: SCM;
}
extern "C" {
    #[link_name = "scm_sym_arrow"]
    pub static mut scm_sym_arrow: SCM;
}
extern "C" {
    #[link_name = "scm_sym_else"]
    pub static mut scm_sym_else: SCM;
}
extern "C" {
    #[link_name = "scm_sym_apply"]
    pub static mut scm_sym_apply: SCM;
}
extern "C" {
    #[link_name = "scm_sym_set_x"]
    pub static mut scm_sym_set_x: SCM;
}
extern "C" {
    #[link_name = "scm_sym_args"]
    pub static mut scm_sym_args: SCM;
}
pub const SCM_M_SEQ: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_SEQ;
pub const SCM_M_IF: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_IF;
pub const SCM_M_LAMBDA: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_LAMBDA;
pub const SCM_M_CAPTURE_ENV: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_CAPTURE_ENV;
pub const SCM_M_LET: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_LET;
pub const SCM_M_QUOTE: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_QUOTE;
pub const SCM_M_CAPTURE_MODULE: _bindgen_ty_3 =
    _bindgen_ty_3::SCM_M_CAPTURE_MODULE;
pub const SCM_M_APPLY: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_APPLY;
pub const SCM_M_CONT: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_CONT;
pub const SCM_M_CALL_WITH_VALUES: _bindgen_ty_3 =
    _bindgen_ty_3::SCM_M_CALL_WITH_VALUES;
pub const SCM_M_CALL: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_CALL;
pub const SCM_M_LEXICAL_REF: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_LEXICAL_REF;
pub const SCM_M_LEXICAL_SET: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_LEXICAL_SET;
pub const SCM_M_BOX_REF: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_BOX_REF;
pub const SCM_M_BOX_SET: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_BOX_SET;
pub const SCM_M_RESOLVE: _bindgen_ty_3 = _bindgen_ty_3::SCM_M_RESOLVE;
pub const SCM_M_CALL_WITH_PROMPT: _bindgen_ty_3 =
    _bindgen_ty_3::SCM_M_CALL_WITH_PROMPT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    SCM_M_SEQ = 0,
    SCM_M_IF = 1,
    SCM_M_LAMBDA = 2,
    SCM_M_CAPTURE_ENV = 3,
    SCM_M_LET = 4,
    SCM_M_QUOTE = 5,
    SCM_M_CAPTURE_MODULE = 6,
    SCM_M_APPLY = 7,
    SCM_M_CONT = 8,
    SCM_M_CALL_WITH_VALUES = 9,
    SCM_M_CALL = 10,
    SCM_M_LEXICAL_REF = 11,
    SCM_M_LEXICAL_SET = 12,
    SCM_M_BOX_REF = 13,
    SCM_M_BOX_SET = 14,
    SCM_M_RESOLVE = 15,
    SCM_M_CALL_WITH_PROMPT = 16,
}
extern "C" {
    pub fn scm_memoize_expression(exp: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unmemoize_expression(memoized: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memoized_typecode(sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_resolve_variable(loc: SCM, module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_memoize();
}
pub type scm_t_trampoline_0 =
    ::std::option::Option<unsafe extern "C" fn(proc_: SCM) -> SCM>;
pub type scm_t_trampoline_1 =
    ::std::option::Option<unsafe extern "C" fn(proc_: SCM, arg1: SCM) -> SCM>;
pub type scm_t_trampoline_2 =
    ::std::option::Option<unsafe extern "C" fn(proc_: SCM, arg1: SCM,
                                               arg2: SCM) -> SCM>;
extern "C" {
    pub fn scm_call_0(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_1(proc_: SCM, arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_2(proc_: SCM, arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_3(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_4(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_call_5(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM,
                      arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_6(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM,
                      arg5: SCM, arg6: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_7(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM,
                      arg5: SCM, arg6: SCM, arg7: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_8(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM,
                      arg5: SCM, arg6: SCM, arg7: SCM, arg8: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_9(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM,
                      arg5: SCM, arg6: SCM, arg7: SCM, arg8: SCM, arg9: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_call_n(proc_: SCM, argv: *mut SCM, nargs: usize) -> SCM;
}
extern "C" {
    pub fn scm_call(proc_: SCM, ...) -> SCM;
}
extern "C" {
    pub fn scm_apply_0(proc_: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply_1(proc_: SCM, arg1: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply_2(proc_: SCM, arg1: SCM, arg2: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply_3(proc_: SCM, arg1: SCM, arg2: SCM, arg3: SCM, args: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_nconc2last(lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_apply(proc_: SCM, arg1: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_map(proc_: SCM, arg1: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_for_each(proc_: SCM, arg1: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_eval(exp: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eval(exp: SCM, module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_eval();
}
extern "C" {
    pub fn scm_defined_p(sym: SCM, env: SCM) -> SCM;
}
extern "C" {
    pub fn scm_self_evaluating_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_evalext();
}
pub type scm_t_extension_init_func =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn scm_c_register_extension(lib: *const ::std::os::raw::c_char,
                                    init: *const ::std::os::raw::c_char,
                                    func:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *mut ::std::os::raw::c_void)>,
                                    data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_c_load_extension(lib: *const ::std::os::raw::c_char,
                                init: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_load_extension(lib: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_extensions();
}
extern "C" {
    pub fn scm_add_fdes_finalizer_x(fd: SCM, finalizer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_remove_fdes_finalizer_x(fd: SCM, finalizer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_run_fdes_finalizers(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn scm_register_fdes_finalizers();
}
extern "C" {
    pub fn scm_add_feature(str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_program_arguments() -> SCM;
}
extern "C" {
    pub fn scm_set_program_arguments(argc: ::std::os::raw::c_int,
                                     argv: *mut *mut ::std::os::raw::c_char,
                                     first: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_set_program_arguments_scm(lst: SCM) -> SCM;
}
extern "C" {
    #[link_name = "scm_program_arguments_fluid"]
    pub static mut scm_program_arguments_fluid: SCM;
}
extern "C" {
    pub fn scm_init_feature();
}
extern "C" {
    #[link_name = "scm_tc16_dir"]
    pub static mut scm_tc16_dir: scm_t_bits;
}
extern "C" {
    pub fn scm_chown(object: SCM, owner: SCM, group: SCM) -> SCM;
}
extern "C" {
    pub fn scm_chmod(object: SCM, mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_umask(mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open_fdes(path: SCM, flags: SCM, mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open(path: SCM, flags: SCM, mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close(fd_or_port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_fdes(fd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stat(object: SCM, exception_on_error: SCM) -> SCM;
}
extern "C" {
    pub fn scm_link(oldpath: SCM, newpath: SCM) -> SCM;
}
extern "C" {
    pub fn scm_rename(oldname: SCM, newname: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delete_file(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mkdir(path: SCM, mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_rmdir(path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_directory_stream_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_opendir(dirname: SCM) -> SCM;
}
extern "C" {
    pub fn scm_readdir(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_rewinddir(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_closedir(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_chdir(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getcwd() -> SCM;
}
extern "C" {
    pub fn scm_select(reads: SCM, writes: SCM, excepts: SCM, secs: SCM,
                      msecs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fcntl(object: SCM, cmd: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fsync(object: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symlink(oldpath: SCM, newpath: SCM) -> SCM;
}
extern "C" {
    pub fn scm_readlink(path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lstat(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_copy_file(oldfile: SCM, newfile: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dirname(filename: SCM) -> SCM;
}
extern "C" {
    pub fn scm_basename(filename: SCM, suffix: SCM) -> SCM;
}
extern "C" {
    pub fn scm_canonicalize_path(path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sendfile(out: SCM, in_: SCM, count: SCM, offset: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_relativize_path(path: SCM, in_path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_filesys();
}
pub type scm_t_finalizer_proc =
    ::std::option::Option<unsafe extern "C" fn(obj:
                                                   *mut ::std::os::raw::c_void,
                                               data:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn scm_i_set_finalizer(obj: *mut ::std::os::raw::c_void,
                               arg1: scm_t_finalizer_proc,
                               data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_i_add_finalizer(obj: *mut ::std::os::raw::c_void,
                               arg1: scm_t_finalizer_proc,
                               data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_i_add_resuscitator(obj: *mut ::std::os::raw::c_void,
                                  arg1: scm_t_finalizer_proc,
                                  data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_i_finalizer_pre_fork();
}
extern "C" {
    pub fn scm_i_register_async_gc_callback(callback:
                                                ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn scm_set_automatic_finalization_enabled(enabled_p:
                                                      ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_run_finalizers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_finalizers();
}
extern "C" {
    pub fn scm_init_finalizer_thread();
}
extern "C" {
    pub fn scm_vector_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_length(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_ref(v: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_set_x(v: SCM, k: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_vector(k: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_to_list(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_fill_x(v: SCM, fill_x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_move_left_x(vec1: SCM, start1: SCM, end1: SCM,
                                  vec2: SCM, start2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_move_right_x(vec1: SCM, start1: SCM, end1: SCM,
                                   vec2: SCM, start2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_vector_copy(vec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_vector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_simple_vector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_make_vector(len: usize, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_vector_length(vec: SCM) -> usize;
}
extern "C" {
    pub fn scm_c_vector_ref(vec: SCM, k: usize) -> SCM;
}
extern "C" {
    pub fn scm_c_vector_set_x(vec: SCM, k: usize, obj: SCM);
}
extern "C" {
    pub fn scm_vector_elements(vec: SCM, h: *mut scm_t_array_handle,
                               lenp: *mut usize, incp: *mut isize)
     -> *const SCM;
}
extern "C" {
    pub fn scm_vector_writable_elements(vec: SCM, h: *mut scm_t_array_handle,
                                        lenp: *mut usize, incp: *mut isize)
     -> *mut SCM;
}
extern "C" {
    pub fn scm_i_vector_equal_p(x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_vectors();
}
extern "C" {
    pub fn scm_make_fluid() -> SCM;
}
extern "C" {
    pub fn scm_make_fluid_with_default(dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_unbound_fluid() -> SCM;
}
extern "C" {
    pub fn scm_make_thread_local_fluid(dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_fluid(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_fluid_p(fl: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_thread_local_p(fluid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_ref(fluid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_ref_star(fluid: SCM, depth: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_set_x(fluid: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_unset_x(fluid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fluid_bound_p(fluid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_swap_fluid(fluid: SCM, value_box: SCM,
                          dynamic_state: *mut scm_t_dynamic_state);
}
extern "C" {
    pub fn scm_c_with_fluids(fluids: SCM, vals: SCM,
                             cproc:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::std::os::raw::c_void)
                                                           -> SCM>,
                             cdata: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_c_with_fluid(fluid: SCM, val: SCM,
                            cproc:
                                ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut ::std::os::raw::c_void)
                                                          -> SCM>,
                            cdata: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_with_fluids(fluids: SCM, vals: SCM, thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_with_fluid(fluid: SCM, val: SCM, thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_fluid(fluid: SCM, value: SCM);
}
extern "C" {
    pub fn scm_dynamic_state_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_dynamic_state(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_current_dynamic_state() -> SCM;
}
extern "C" {
    pub fn scm_set_current_dynamic_state(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_current_dynamic_state(state: SCM);
}
extern "C" {
    pub fn scm_c_with_dynamic_state(state: SCM,
                                    func:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *mut ::std::os::raw::c_void)
                                                                  ->
                                                                      *mut ::std::os::raw::c_void>,
                                    data: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_with_dynamic_state(state: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_state_ref(state: SCM, fluid: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_initial_dynamic_state() -> SCM;
}
extern "C" {
    pub fn scm_i_fluid_print(exp: SCM, port: SCM,
                             pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_i_dynamic_state_print(exp: SCM, port: SCM,
                                     pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_fluids();
}
pub const scm_t_foreign_type_SCM_FOREIGN_TYPE_LAST: scm_t_foreign_type =
    scm_t_foreign_type::SCM_FOREIGN_TYPE_INT64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_foreign_type {
    SCM_FOREIGN_TYPE_VOID = 0,
    SCM_FOREIGN_TYPE_FLOAT = 1,
    SCM_FOREIGN_TYPE_DOUBLE = 2,
    SCM_FOREIGN_TYPE_UINT8 = 3,
    SCM_FOREIGN_TYPE_INT8 = 4,
    SCM_FOREIGN_TYPE_UINT16 = 5,
    SCM_FOREIGN_TYPE_INT16 = 6,
    SCM_FOREIGN_TYPE_UINT32 = 7,
    SCM_FOREIGN_TYPE_INT32 = 8,
    SCM_FOREIGN_TYPE_UINT64 = 9,
    SCM_FOREIGN_TYPE_INT64 = 10,
}
pub type scm_t_pointer_finalizer =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn scm_to_pointer(pointer: SCM) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_from_pointer(arg1: *mut ::std::os::raw::c_void,
                            arg2: scm_t_pointer_finalizer) -> SCM;
}
extern "C" {
    pub fn scm_alignof(type_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sizeof(type_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_address(pointer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_to_scm(pointer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_scm_to_pointer(scm: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_to_bytevector(pointer: SCM, type_: SCM, offset: SCM,
                                     len: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_pointer_finalizer_x(pointer: SCM, finalizer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bytevector_to_pointer(bv: SCM, offset: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_pointer(address: SCM, finalizer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_pointer_print(pointer: SCM, port: SCM,
                               pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_dereference_pointer(pointer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_pointer(string: SCM, encoding: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_to_string(pointer: SCM, length: SCM, encoding: SCM)
     -> SCM;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_vm_stack_element {
    pub as_uint: __BindgenUnionField<scm_t_uintptr>,
    pub as_ip: __BindgenUnionField<*mut scm_t_uint32>,
    pub as_scm: __BindgenUnionField<SCM>,
    pub as_f64: __BindgenUnionField<f64>,
    pub as_u64: __BindgenUnionField<scm_t_uint64>,
    pub as_s64: __BindgenUnionField<scm_t_int64>,
    pub as_ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub as_bits: __BindgenUnionField<scm_t_bits>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_scm_vm_stack_element() {
    assert_eq!(::std::mem::size_of::<scm_vm_stack_element>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( scm_vm_stack_element ) ));
    assert_eq! (::std::mem::align_of::<scm_vm_stack_element>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( scm_vm_stack_element ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_vm_stack_element ) ) . as_uint as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_vm_stack_element )
                , "::" , stringify ! ( as_uint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_vm_stack_element ) ) . as_ip as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_vm_stack_element )
                , "::" , stringify ! ( as_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_vm_stack_element ) ) . as_scm as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_vm_stack_element )
                , "::" , stringify ! ( as_scm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_vm_stack_element ) ) . as_f64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_vm_stack_element )
                , "::" , stringify ! ( as_f64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_vm_stack_element ) ) . as_u64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_vm_stack_element )
                , "::" , stringify ! ( as_u64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_vm_stack_element ) ) . as_s64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_vm_stack_element )
                , "::" , stringify ! ( as_s64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_vm_stack_element ) ) . as_ptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_vm_stack_element )
                , "::" , stringify ! ( as_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_vm_stack_element ) ) . as_bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_vm_stack_element )
                , "::" , stringify ! ( as_bits ) ));
}
impl Clone for scm_vm_stack_element {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn scm_pointer_to_procedure(return_type: SCM, func_ptr: SCM,
                                    arg_types: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pointer_to_procedure_with_errno(return_type: SCM,
                                               func_ptr: SCM, arg_types: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_procedure_to_pointer(return_type: SCM, func_ptr: SCM,
                                    arg_types: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_foreign_call(cif_scm: SCM, pointer_scm: SCM,
                              errno_ret: *mut ::std::os::raw::c_int,
                              argv: *const scm_vm_stack_element) -> SCM;
}
extern "C" {
    pub fn scm_register_foreign();
}
extern "C" {
    pub fn scm_make_foreign_object_type(name: SCM, slot_names: SCM,
                                        finalizer: scm_t_struct_finalize)
     -> SCM;
}
extern "C" {
    pub fn scm_assert_foreign_object_type(type_: SCM, val: SCM);
}
extern "C" {
    pub fn scm_make_foreign_object_0(type_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_foreign_object_1(type_: SCM,
                                     val0: *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_make_foreign_object_2(type_: SCM,
                                     val0: *mut ::std::os::raw::c_void,
                                     val1: *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_make_foreign_object_3(type_: SCM,
                                     val0: *mut ::std::os::raw::c_void,
                                     val1: *mut ::std::os::raw::c_void,
                                     val2: *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_make_foreign_object_n(type_: SCM, n: usize,
                                     vals: *mut *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_foreign_object_ref(obj: SCM, n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_foreign_object_set_x(obj: SCM, n: usize,
                                    val: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_foreign_object_unsigned_ref(obj: SCM, n: usize) -> scm_t_bits;
}
extern "C" {
    pub fn scm_foreign_object_unsigned_set_x(obj: SCM, n: usize,
                                             val: scm_t_bits);
}
extern "C" {
    pub fn scm_foreign_object_signed_ref(obj: SCM, n: usize)
     -> scm_t_signed_bits;
}
extern "C" {
    pub fn scm_foreign_object_signed_set_x(obj: SCM, n: usize,
                                           val: scm_t_signed_bits);
}
extern "C" {
    pub fn scm_register_foreign_object();
}
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(arg1: ::std::os::raw::c_int,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                        arg4: *const ::std::os::raw::c_char,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __nitems: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __prefix: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__str: *mut ::std::os::raw::c_char, __size: usize,
                     __format: *const ::std::os::raw::c_char,
                     arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__str: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   arg1: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(__linep: *mut *mut ::std::os::raw::c_char,
                    __linecapp: *mut usize,
                    __delimiter: ::std::os::raw::c_int, __stream: *mut FILE)
     -> isize;
}
extern "C" {
    pub fn getline(__linep: *mut *mut ::std::os::raw::c_char,
                   __linecapp: *mut usize, __stream: *mut FILE) -> isize;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dst: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dst: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__b: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(__s1: *mut ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(__dst: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __charset: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(__s1: *mut ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(__dst: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __charset: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __charset: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(__big: *const ::std::os::raw::c_char,
                  __little: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__str: *mut ::std::os::raw::c_char,
                  __sep: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(__s1: *mut ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(__str: *mut ::std::os::raw::c_char,
                    __sep: *const ::std::os::raw::c_char,
                    __lasts: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __strerrbuf: *mut ::std::os::raw::c_char,
                      __buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(__dst: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(__dst: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dst: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__s1: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memset_s(__s: *mut ::std::os::raw::c_void, __smax: rsize_t,
                    __c: ::std::os::raw::c_int, __n: rsize_t) -> errno_t;
}
extern "C" {
    pub fn memmem(__big: *const ::std::os::raw::c_void, __big_len: usize,
                  __little: *const ::std::os::raw::c_void,
                  __little_len: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(__b: *mut ::std::os::raw::c_void,
                           __pattern4: *const ::std::os::raw::c_void,
                           __len: usize);
}
extern "C" {
    pub fn memset_pattern8(__b: *mut ::std::os::raw::c_void,
                           __pattern8: *const ::std::os::raw::c_void,
                           __len: usize);
}
extern "C" {
    pub fn memset_pattern16(__b: *mut ::std::os::raw::c_void,
                            __pattern16: *const ::std::os::raw::c_void,
                            __len: usize);
}
extern "C" {
    pub fn strcasestr(__big: *const ::std::os::raw::c_char,
                      __little: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(__big: *const ::std::os::raw::c_char,
                   __little: *const ::std::os::raw::c_char, __len: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(__dst: *mut ::std::os::raw::c_char,
                   __source: *const ::std::os::raw::c_char, __size: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(__dst: *mut ::std::os::raw::c_char,
                   __source: *const ::std::os::raw::c_char, __size: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int,
                   __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(arg1: *const ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void, arg3: isize);
}
extern "C" {
    pub fn timingsafe_bcmp(__b1: *const ::std::os::raw::c_void,
                           __b2: *const ::std::os::raw::c_void, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::std::os::raw::c_void,
                 arg2: *mut ::std::os::raw::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn index(arg1: *const ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::std::os::raw::c_char,
                       arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    assert_eq!(::std::mem::size_of::<accessx_descriptor>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( accessx_descriptor ) ));
    assert_eq! (::std::mem::align_of::<accessx_descriptor>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( accessx_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accessx_descriptor ) ) . ad_name_offset
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( accessx_descriptor ) ,
                "::" , stringify ! ( ad_name_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accessx_descriptor ) ) . ad_flags as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( accessx_descriptor ) ,
                "::" , stringify ! ( ad_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accessx_descriptor ) ) . ad_pad as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( accessx_descriptor ) ,
                "::" , stringify ! ( ad_pad ) ));
}
impl Clone for accessx_descriptor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getattrlistbulk(arg1: ::std::os::raw::c_int,
                           arg2: *mut ::std::os::raw::c_void,
                           arg3: *mut ::std::os::raw::c_void, arg4: usize,
                           arg5: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(arg1: ::std::os::raw::c_int,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int, arg4: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char, arg3: uid_t,
                    arg4: gid_t, arg5: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int,
                  arg4: *const ::std::os::raw::c_char,
                  arg5: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(arg1: ::std::os::raw::c_int,
                      arg2: *const ::std::os::raw::c_char,
                      arg3: *mut ::std::os::raw::c_char, arg4: usize)
     -> isize;
}
extern "C" {
    pub fn symlinkat(arg1: *const ::std::os::raw::c_char,
                     arg2: ::std::os::raw::c_int,
                     arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlistat(arg1: ::std::os::raw::c_int,
                         arg2: *const ::std::os::raw::c_char,
                         arg3: *mut ::std::os::raw::c_void,
                         arg4: *mut ::std::os::raw::c_void, arg5: usize,
                         arg6: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn access(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(arg1: *const ::std::os::raw::c_char, arg2: uid_t,
                 arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(__path: *const ::std::os::raw::c_char,
                 __arg0: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(__path: *const ::std::os::raw::c_char,
                  __arg0: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(__file: *const ::std::os::raw::c_char,
                  __arg0: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(__path: *const ::std::os::raw::c_char,
                 __argv: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(__file: *const ::std::os::raw::c_char,
                  __argv: *const *const ::std::os::raw::c_char,
                  __envp: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(__file: *const ::std::os::raw::c_char,
                  __argv: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(arg1: *const ::std::os::raw::c_char,
                arg2: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t,
                 arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn pathconf(arg1: *const ::std::os::raw::c_char,
                    arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(arg1: ::std::os::raw::c_int,
                arg2: *mut ::std::os::raw::c_void, arg3: usize) -> isize;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(arg1: ::std::os::raw::c_int,
                     arg2: *mut ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(__fd: ::std::os::raw::c_int,
                 __buf: *const ::std::os::raw::c_void, __nbyte: usize)
     -> isize;
}
extern "C" {
    pub fn confstr(arg1: ::std::os::raw::c_int,
                   arg2: *mut ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn getopt(arg1: ::std::os::raw::c_int,
                  arg2: *const *const ::std::os::raw::c_char,
                  arg3: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optarg"]
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "optind"]
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "opterr"]
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optopt"]
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char,
                   arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lchown(arg1: *const ::std::os::raw::c_char, arg2: uid_t,
                  arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int,
                 arg3: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(__fd: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_void, __nbyte: usize,
                 __offset: off_t) -> isize;
}
extern "C" {
    pub fn pwrite(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __nbyte: usize,
                  __offset: off_t) -> isize;
}
extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut ::std::os::raw::c_char, arg3: usize) -> isize;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn accessx_np(arg1: *const accessx_descriptor, arg2: usize,
                      arg3: *mut ::std::os::raw::c_int, arg4: uid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_profil(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                      arg3: ::std::os::raw::c_ulong,
                      arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execvP(__file: *const ::std::os::raw::c_char,
                  __searchpath: *const ::std::os::raw::c_char,
                  __argv: *const *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getgrouplist(arg1: *const ::std::os::raw::c_char,
                        arg2: ::std::os::raw::c_int,
                        arg3: *mut ::std::os::raw::c_int,
                        arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostuuid(arg1: *mut ::std::os::raw::c_uchar,
                       arg2: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t)
     -> mode_t;
}
extern "C" {
    pub fn getpeereid(arg1: ::std::os::raw::c_int, arg2: *mut uid_t,
                      arg3: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsgroups_np(arg1: *mut ::std::os::raw::c_int,
                         arg2: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwgroups_np(arg1: *mut ::std::os::raw::c_int,
                         arg2: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initgroups(arg1: *const ::std::os::raw::c_char,
                      arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mknod(arg1: *const ::std::os::raw::c_char, arg2: mode_t,
                 arg3: dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpathat_np(dfd: ::std::os::raw::c_int,
                       path: *const ::std::os::raw::c_char, omode: mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut ::std::os::raw::c_char,
                    arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(path: *mut ::std::os::raw::c_char,
                    oflags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(path: *mut ::std::os::raw::c_char,
                     slen: ::std::os::raw::c_int,
                     oflags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp_dprotected_np(path: *mut ::std::os::raw::c_char,
                                 dpclass: ::std::os::raw::c_int,
                                 dpflags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nfssvc(arg1: ::std::os::raw::c_int,
                  arg2: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                  arg3: ::std::os::raw::c_ulong, arg4: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(arg1: *mut *mut ::std::os::raw::c_char,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: *const ::std::os::raw::c_char,
                arg5: *const ::std::os::raw::c_char,
                arg6: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(arg1: *mut *mut ::std::os::raw::c_char,
                   arg2: ::std::os::raw::c_int,
                   arg3: *const ::std::os::raw::c_char,
                   arg4: *const ::std::os::raw::c_char,
                   arg5: *const ::std::os::raw::c_char,
                   arg6: *mut ::std::os::raw::c_int,
                   arg7: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(arg1: *mut ::std::os::raw::c_int,
                        arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(arg1: ::std::os::raw::c_ulong,
                    arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_sa(arg1: *const ::std::os::raw::c_void,
                       arg2: ::std::os::raw::c_int,
                       arg3: ::std::os::raw::c_int,
                       arg4: *const ::std::os::raw::c_char,
                       arg5: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(arg1: *const ::std::os::raw::c_char,
                   arg2: ::std::os::raw::c_int,
                   arg3: *const ::std::os::raw::c_char,
                   arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(arg1: *const ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn sethostname(arg1: *const ::std::os::raw::c_char,
                       arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsgroups_np(arg1: ::std::os::raw::c_int,
                         arg2: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn setwgroups_np(arg1: ::std::os::raw::c_int,
                         arg2: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtofflags(arg1: *mut *mut ::std::os::raw::c_char,
                       arg2: *mut ::std::os::raw::c_ulong,
                       arg3: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetattrlist(arg1: ::std::os::raw::c_int,
                        arg2: *mut ::std::os::raw::c_void,
                        arg3: *mut ::std::os::raw::c_void, arg4: usize,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetattrlist(arg1: ::std::os::raw::c_int,
                        arg2: *mut ::std::os::raw::c_void,
                        arg3: *mut ::std::os::raw::c_void, arg4: usize,
                        arg5: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlist(arg1: *const ::std::os::raw::c_char,
                       arg2: *mut ::std::os::raw::c_void,
                       arg3: *mut ::std::os::raw::c_void, arg4: usize,
                       arg5: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlist(arg1: *const ::std::os::raw::c_char,
                       arg2: *mut ::std::os::raw::c_void,
                       arg3: *mut ::std::os::raw::c_void, arg4: usize,
                       arg5: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exchangedata(arg1: *const ::std::os::raw::c_char,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentriesattr(arg1: ::std::os::raw::c_int,
                             arg2: *mut ::std::os::raw::c_void,
                             arg3: *mut ::std::os::raw::c_void, arg4: usize,
                             arg5: *mut ::std::os::raw::c_uint,
                             arg6: *mut ::std::os::raw::c_uint,
                             arg7: *mut ::std::os::raw::c_uint,
                             arg8: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn searchfs(arg1: *const ::std::os::raw::c_char,
                    arg2: *mut fssearchblock,
                    arg3: *mut ::std::os::raw::c_ulong,
                    arg4: ::std::os::raw::c_uint,
                    arg5: ::std::os::raw::c_uint, arg6: *mut searchstate)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsctl(arg1: *const ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_ulong,
                 arg3: *mut ::std::os::raw::c_void,
                 arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsctl(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_ulong,
                  arg3: *mut ::std::os::raw::c_void,
                  arg4: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync_volume_np(arg1: ::std::os::raw::c_int,
                           arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_volume_np(arg1: *const ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "optreset"]
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_string_failed_conversion_handler {
    SCM_FAILED_CONVERSION_ERROR = 0,
    SCM_FAILED_CONVERSION_QUESTION_MARK = 1,
    SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE = 2,
}
extern "C" {
    #[link_name = "scm_nullstr"]
    pub static mut scm_nullstr: SCM;
}
extern "C" {
    pub fn scm_i_default_string_failed_conversion_handler()
     -> scm_t_string_failed_conversion_handler;
}
extern "C" {
    pub fn scm_string_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string(chrs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_string(k: SCM, chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_length(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_utf8_length(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_bytes_per_char(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ref(str: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_set_x(str: SCM, k: SCM, chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_read_only(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_shared(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_copy(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_append(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_from_stringn(str: *const ::std::os::raw::c_char, len: usize,
                            encoding: *const ::std::os::raw::c_char,
                            handler: scm_t_string_failed_conversion_handler)
     -> SCM;
}
extern "C" {
    pub fn scm_c_make_string(len: usize, chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_string_length(str: SCM) -> usize;
}
extern "C" {
    pub fn scm_c_string_utf8_length(str: SCM) -> usize;
}
extern "C" {
    pub fn scm_c_symbol_length(sym: SCM) -> usize;
}
extern "C" {
    pub fn scm_c_string_ref(str: SCM, pos: usize) -> SCM;
}
extern "C" {
    pub fn scm_c_string_set_x(str: SCM, pos: usize, chr: SCM);
}
extern "C" {
    pub fn scm_c_substring(str: SCM, start: usize, end: usize) -> SCM;
}
extern "C" {
    pub fn scm_c_substring_read_only(str: SCM, start: usize, end: usize)
     -> SCM;
}
extern "C" {
    pub fn scm_c_substring_shared(str: SCM, start: usize, end: usize) -> SCM;
}
extern "C" {
    pub fn scm_c_substring_copy(str: SCM, start: usize, end: usize) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_string(str: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_stringn(str: *const ::std::os::raw::c_char,
                                   len: usize) -> SCM;
}
extern "C" {
    pub fn scm_take_locale_string(str: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_locale_stringn(str: *mut ::std::os::raw::c_char,
                                   len: usize) -> SCM;
}
extern "C" {
    pub fn scm_to_locale_string(str: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_locale_stringn(str: SCM, lenp: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_from_latin1_string(str: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_latin1_stringn(str: *const ::std::os::raw::c_char,
                                   len: usize) -> SCM;
}
extern "C" {
    pub fn scm_to_latin1_string(str: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_latin1_stringn(str: SCM, lenp: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_utf8_string(str: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_utf8_stringn(str: SCM, lenp: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_from_utf8_string(str: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_utf8_stringn(str: *const ::std::os::raw::c_char,
                                 len: usize) -> SCM;
}
extern "C" {
    pub fn scm_to_utf32_string(str: SCM) -> *mut scm_t_wchar;
}
extern "C" {
    pub fn scm_to_utf32_stringn(str: SCM, lenp: *mut usize)
     -> *mut scm_t_wchar;
}
extern "C" {
    pub fn scm_from_utf32_string(str: *const scm_t_wchar) -> SCM;
}
extern "C" {
    pub fn scm_from_utf32_stringn(str: *const scm_t_wchar, len: usize) -> SCM;
}
extern "C" {
    pub fn scm_to_port_string(str: SCM, port: SCM)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_port_stringn(str: SCM, lenp: *mut usize, port: SCM)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_from_port_string(str: *const ::std::os::raw::c_char, port: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_from_port_stringn(str: *const ::std::os::raw::c_char,
                                 len: usize, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_to_stringn(str: SCM, lenp: *mut usize,
                          encoding: *const ::std::os::raw::c_char,
                          handler: scm_t_string_failed_conversion_handler)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_to_locale_stringbuf(str: SCM, buf: *mut ::std::os::raw::c_char,
                                   max_len: usize) -> usize;
}
extern "C" {
    pub fn scm_string_normalize_nfd(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_normalize_nfkd(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_normalize_nfc(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_normalize_nfkc(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_makfromstrs(argc: ::std::os::raw::c_int,
                           argv: *mut *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_i_print_stringbuf(exp: SCM, port: SCM,
                                 pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_i_make_string(len: usize,
                             datap: *mut *mut ::std::os::raw::c_char,
                             read_only_p: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_i_make_wide_string(len: usize, datap: *mut *mut scm_t_wchar,
                                  read_only_p: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_i_substring(str: SCM, start: usize, end: usize) -> SCM;
}
extern "C" {
    pub fn scm_i_substring_read_only(str: SCM, start: usize, end: usize)
     -> SCM;
}
extern "C" {
    pub fn scm_i_substring_shared(str: SCM, start: usize, end: usize) -> SCM;
}
extern "C" {
    pub fn scm_i_substring_copy(str: SCM, start: usize, end: usize) -> SCM;
}
extern "C" {
    pub fn scm_i_string_length(str: SCM) -> usize;
}
extern "C" {
    pub fn scm_i_string_is_mutable(str: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_string_chars(str: SCM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_string_writable_chars(str: SCM)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_string_wide_chars(str: SCM) -> *const scm_t_wchar;
}
extern "C" {
    pub fn scm_i_string_data(str: SCM) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_i_string_start_writing(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_string_stop_writing();
}
extern "C" {
    pub fn scm_i_is_narrow_string(str: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_string_ref(str: SCM, x: usize) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_i_string_contains_char(str: SCM, c: ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_string_strcmp(sstr: SCM, start_x: usize,
                               cstr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_string_set_x(str: SCM, p: usize, chr: scm_t_wchar);
}
extern "C" {
    pub fn scm_i_make_symbol(name: SCM, flags: scm_t_bits,
                             hash: ::std::os::raw::c_ulong, props: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_i_c_make_symbol(name: *const ::std::os::raw::c_char,
                               len: usize, flags: scm_t_bits,
                               hash: ::std::os::raw::c_ulong, props: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_i_symbol_chars(sym: SCM) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_symbol_wide_chars(sym: SCM) -> *const scm_t_wchar;
}
extern "C" {
    pub fn scm_i_symbol_length(sym: SCM) -> usize;
}
extern "C" {
    pub fn scm_i_is_narrow_symbol(str: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_try_narrow_string(str: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_symbol_substring(sym: SCM, start: usize, end: usize) -> SCM;
}
extern "C" {
    pub fn scm_i_symbol_ref(sym: SCM, x: usize) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_encoding_error(subr: *const ::std::os::raw::c_char,
                              err: ::std::os::raw::c_int,
                              message: *const ::std::os::raw::c_char,
                              port: SCM, chr: SCM);
}
extern "C" {
    pub fn scm_decoding_error(subr: *const ::std::os::raw::c_char,
                              err: ::std::os::raw::c_int,
                              message: *const ::std::os::raw::c_char,
                              port: SCM);
}
extern "C" {
    pub fn scm_i_allocate_string_pointers(list: SCM)
     -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_get_substring_spec(len: usize, start: SCM,
                                    cstart: *mut usize, end: SCM,
                                    cend: *mut usize);
}
extern "C" {
    pub fn scm_sys_string_dump(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_symbol_dump(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_strings();
}
extern "C" {
    #[link_name = "scm_i_port_weak_set"]
    pub static mut scm_i_port_weak_set: SCM;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_port_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scm_t_port {
    _unused: [u8; 0],
}
extern "C" {
    pub fn scm_make_port_type(name: *mut ::std::os::raw::c_char,
                              read:
                                  ::std::option::Option<unsafe extern "C" fn(port:
                                                                                 SCM,
                                                                             dst:
                                                                                 SCM,
                                                                             start:
                                                                                 usize,
                                                                             count:
                                                                                 usize)
                                                            -> usize>,
                              write:
                                  ::std::option::Option<unsafe extern "C" fn(port:
                                                                                 SCM,
                                                                             src:
                                                                                 SCM,
                                                                             start:
                                                                                 usize,
                                                                             count:
                                                                                 usize)
                                                            -> usize>)
     -> *mut scm_t_port_type;
}
extern "C" {
    pub fn scm_set_port_scm_read(ptob: *mut scm_t_port_type, read: SCM);
}
extern "C" {
    pub fn scm_set_port_scm_write(ptob: *mut scm_t_port_type, write: SCM);
}
extern "C" {
    pub fn scm_set_port_read_wait_fd(ptob: *mut scm_t_port_type,
                                     wait_fd:
                                         ::std::option::Option<unsafe extern "C" fn(port:
                                                                                        SCM)
                                                                   ->
                                                                       ::std::os::raw::c_int>);
}
extern "C" {
    pub fn scm_set_port_write_wait_fd(ptob: *mut scm_t_port_type,
                                      wait_fd:
                                          ::std::option::Option<unsafe extern "C" fn(port:
                                                                                         SCM)
                                                                    ->
                                                                        ::std::os::raw::c_int>);
}
extern "C" {
    pub fn scm_set_port_print(ptob: *mut scm_t_port_type,
                              print:
                                  ::std::option::Option<unsafe extern "C" fn(exp:
                                                                                 SCM,
                                                                             port:
                                                                                 SCM,
                                                                             pstate:
                                                                                 *mut scm_print_state)
                                                            ->
                                                                ::std::os::raw::c_int>);
}
extern "C" {
    pub fn scm_set_port_close(ptob: *mut scm_t_port_type,
                              close:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 SCM)>);
}
extern "C" {
    pub fn scm_set_port_needs_close_on_gc(ptob: *mut scm_t_port_type,
                                          needs_close_p:
                                              ::std::os::raw::c_int);
}
extern "C" {
    pub fn scm_set_port_seek(ptob: *mut scm_t_port_type,
                             seek:
                                 ::std::option::Option<unsafe extern "C" fn(port:
                                                                                SCM,
                                                                            OFFSET:
                                                                                scm_t_off,
                                                                            WHENCE:
                                                                                ::std::os::raw::c_int)
                                                           -> scm_t_off>);
}
extern "C" {
    pub fn scm_set_port_truncate(ptob: *mut scm_t_port_type,
                                 truncate:
                                     ::std::option::Option<unsafe extern "C" fn(port:
                                                                                    SCM,
                                                                                length:
                                                                                    scm_t_off)>);
}
extern "C" {
    pub fn scm_set_port_input_waiting(ptob: *mut scm_t_port_type,
                                      input_waiting:
                                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         SCM)
                                                                    ->
                                                                        ::std::os::raw::c_int>);
}
extern "C" {
    pub fn scm_set_port_get_natural_buffer_sizes(ptob: *mut scm_t_port_type,
                                                 get_natural_buffer_sizes:
                                                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                    SCM,
                                                                                                arg2:
                                                                                                    *mut usize,
                                                                                                arg3:
                                                                                                    *mut usize)>);
}
extern "C" {
    pub fn scm_set_port_random_access_p(ptob: *mut scm_t_port_type,
                                        random_access_p:
                                            ::std::option::Option<unsafe extern "C" fn(port:
                                                                                           SCM)
                                                                      ->
                                                                          ::std::os::raw::c_int>);
}
extern "C" {
    pub fn scm_current_input_port() -> SCM;
}
extern "C" {
    pub fn scm_current_output_port() -> SCM;
}
extern "C" {
    pub fn scm_current_error_port() -> SCM;
}
extern "C" {
    pub fn scm_current_warning_port() -> SCM;
}
extern "C" {
    pub fn scm_current_load_port() -> SCM;
}
extern "C" {
    pub fn scm_set_current_input_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_current_output_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_current_error_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_current_warning_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynwind_current_input_port(port: SCM);
}
extern "C" {
    pub fn scm_dynwind_current_output_port(port: SCM);
}
extern "C" {
    pub fn scm_dynwind_current_error_port(port: SCM);
}
extern "C" {
    pub fn scm_i_dynwind_current_load_port(port: SCM);
}
extern "C" {
    pub fn scm_i_mode_bits(modes: SCM) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_mode_bits(modes: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_port_mode(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_make_port_with_encoding(ptob: *mut scm_t_port_type,
                                         mode_bits: ::std::os::raw::c_ulong,
                                         encoding: SCM,
                                         conversion_strategy: SCM,
                                         stream: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_c_make_port(ptob: *mut scm_t_port_type,
                           mode_bits: ::std::os::raw::c_ulong,
                           stream: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_port_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_input_port_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_output_port_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_closed_p(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eof_object_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_input_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_output_port(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_string_failed_conversion_handler(conversion_strategy: SCM)
     -> scm_t_string_failed_conversion_handler;
}
extern "C" {
    pub fn scm_i_default_port_encoding() -> SCM;
}
extern "C" {
    pub fn scm_i_set_default_port_encoding(encoding:
                                               *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_i_default_port_conversion_strategy() -> SCM;
}
extern "C" {
    pub fn scm_i_set_default_port_conversion_strategy(strategy: SCM);
}
extern "C" {
    pub fn scm_i_set_port_encoding_x(port: SCM,
                                     str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_sys_port_encoding(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_set_port_encoding_x(port: SCM, encoding: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_encoding(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_encoding_x(port: SCM, encoding: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_conversion_strategy(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_conversion_strategy_x(port: SCM, behavior: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_port_maybe_consume_initial_byte_order_mark(arg1: SCM,
                                                          arg2: SCM,
                                                          arg3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_byte_or_eof(port: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_peek_byte_or_eof(port: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_read(port: SCM, buffer: *mut ::std::os::raw::c_void,
                      size: usize) -> usize;
}
extern "C" {
    pub fn scm_c_read_bytes(port: SCM, dst: SCM, start: usize, count: usize)
     -> usize;
}
extern "C" {
    pub fn scm_getc(port: SCM) -> scm_t_wchar;
}
extern "C" {
    pub fn scm_read_char(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unget_bytes(buf: *const ::std::os::raw::c_uchar, len: usize,
                           port: SCM);
}
extern "C" {
    pub fn scm_unget_byte(c: ::std::os::raw::c_int, port: SCM);
}
extern "C" {
    pub fn scm_ungetc(c: scm_t_wchar, port: SCM);
}
extern "C" {
    pub fn scm_ungets(s: *const ::std::os::raw::c_char,
                      n: ::std::os::raw::c_int, port: SCM);
}
extern "C" {
    pub fn scm_peek_char(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unread_char(cobj: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unread_string(str: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setvbuf(port: SCM, mode: SCM, size: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fill_input(port: SCM, minimum_size: usize, cur_out: *mut usize,
                          avail_out: *mut usize) -> SCM;
}
extern "C" {
    pub fn scm_take_from_input_buffers(port: SCM,
                                       dest: *mut ::std::os::raw::c_char,
                                       read_len: usize) -> usize;
}
extern "C" {
    pub fn scm_drain_input(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_end_input(port: SCM);
}
extern "C" {
    pub fn scm_force_output(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_flush(port: SCM);
}
extern "C" {
    pub fn scm_port_random_access_p(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_read_buffering(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_expand_port_read_buffer_x(port: SCM, size: SCM, putback_p: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_port_read(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_write(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_read_buffer(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_write_buffer(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_auxiliary_write_buffer(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_write(port: SCM, buffer: *const ::std::os::raw::c_void,
                       size: usize);
}
extern "C" {
    pub fn scm_c_write_bytes(port: SCM, src: SCM, start: usize, count: usize);
}
extern "C" {
    pub fn scm_c_put_latin1_chars(port: SCM, buf: *const scm_t_uint8,
                                  len: usize);
}
extern "C" {
    pub fn scm_c_put_utf32_chars(port: SCM, buf: *const scm_t_uint32,
                                 len: usize);
}
extern "C" {
    pub fn scm_c_put_string(port: SCM, str: SCM, start: usize, count: usize);
}
extern "C" {
    pub fn scm_put_string(port: SCM, str: SCM, start: SCM, count: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_put_char(port: SCM, ch: scm_t_wchar);
}
extern "C" {
    pub fn scm_put_char(port: SCM, ch: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_put_escaped_char(port: SCM, ch: scm_t_wchar);
}
extern "C" {
    pub fn scm_c_can_put_char(port: SCM, ch: scm_t_wchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_putc(c: ::std::os::raw::c_char, port: SCM);
}
extern "C" {
    pub fn scm_puts(str_data: *const ::std::os::raw::c_char, port: SCM);
}
extern "C" {
    pub fn scm_lfwrite(ptr: *const ::std::os::raw::c_char, size: usize,
                       port: SCM);
}
extern "C" {
    pub fn scm_lfwrite_substr(str: SCM, start: usize, end: usize, port: SCM);
}
extern "C" {
    pub fn scm_char_ready_p(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_seek(object: SCM, offset: SCM, whence: SCM) -> SCM;
}
extern "C" {
    pub fn scm_truncate_file(object: SCM, length: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_line(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_line_x(port: SCM, line: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_column(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_column_x(port: SCM, line: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_filename(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_filename_x(port: SCM, filename: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_port_property(port: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_set_port_property_x(port: SCM, key: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_port_print(exp: SCM, port: SCM, arg1: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_print_port_mode(exp: SCM, port: SCM);
}
extern "C" {
    pub fn scm_port_for_each(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_port_for_each(proc_:
                                   ::std::option::Option<unsafe extern "C" fn(data:
                                                                                  *mut ::std::os::raw::c_void,
                                                                              p:
                                                                                  SCM)>,
                               data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_flush_all_ports() -> SCM;
}
extern "C" {
    pub fn scm_void_port(mode_str: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_sys_make_void_port(mode: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_ports();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_fport {
    pub fdes: ::std::os::raw::c_int,
    pub revealed: ::std::os::raw::c_int,
    pub options: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_scm_t_fport() {
    assert_eq!(::std::mem::size_of::<scm_t_fport>() , 12usize , concat ! (
               "Size of: " , stringify ! ( scm_t_fport ) ));
    assert_eq! (::std::mem::align_of::<scm_t_fport>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_fport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_fport ) ) . fdes as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_fport ) , "::" ,
                stringify ! ( fdes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_fport ) ) . revealed as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_fport ) , "::" ,
                stringify ! ( revealed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_fport ) ) . options as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_fport ) , "::" ,
                stringify ! ( options ) ));
}
impl Clone for scm_t_fport {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "scm_file_port_type"]
    pub static mut scm_file_port_type: *mut scm_t_port_type;
}
extern "C" {
    pub fn scm_evict_ports(fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn scm_i_mode_to_open_flags(mode: SCM,
                                    is_binary: *mut ::std::os::raw::c_int,
                                    FUNC_NAME: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_open_file_with_encoding(filename: SCM, modes: SCM,
                                       guess_encoding: SCM, encoding: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_open_file(filename: SCM, modes: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fdes_to_port(fdes: ::std::os::raw::c_int,
                            mode: *mut ::std::os::raw::c_char, name: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_file_port_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_revealed_count(port: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_port_revealed(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_port_revealed_x(port: SCM, rcount: SCM) -> SCM;
}
extern "C" {
    pub fn scm_adjust_port_revealed_x(port: SCM, addend: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_fports_keywords();
}
extern "C" {
    pub fn scm_init_fports();
}
extern "C" {
    /// Arrays
    pub fn scm_is_array(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_array_p(v: SCM, unused: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_p_2(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_typed_array(obj: SCM, type_: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_typed_array_p(v: SCM, type_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_array_length(ra: SCM) -> usize;
}
extern "C" {
    pub fn scm_array_length(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_dimensions(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_type(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_type_code(ra: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_in_bounds_p(v: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_array_ref_1(v: SCM, idx0: isize) -> SCM;
}
extern "C" {
    pub fn scm_c_array_ref_2(v: SCM, idx0: isize, idx1: isize) -> SCM;
}
extern "C" {
    pub fn scm_c_array_set_1_x(v: SCM, obj: SCM, idx0: isize);
}
extern "C" {
    pub fn scm_c_array_set_2_x(v: SCM, obj: SCM, idx0: isize, idx1: isize);
}
extern "C" {
    pub fn scm_array_ref(v: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_set_x(v: SCM, obj: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_to_list(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_generalized_arrays();
}
extern "C" {
    pub fn scm_generalized_vector_get_handle(vec: SCM,
                                             h: *mut scm_t_array_handle);
}
extern "C" {
    pub fn scm_make_generalized_vector(type_: SCM, len: SCM, fill: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_i_register_vector_constructor(type_: SCM,
                                             ctor:
                                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                SCM,
                                                                                            arg2:
                                                                                                SCM)
                                                                           ->
                                                                               SCM>);
}
extern "C" {
    pub fn scm_init_generalized_vectors();
}
extern "C" {
    #[link_name = "scm_i_smob_class"]
    pub static mut scm_i_smob_class: [SCM; 0usize];
}
extern "C" {
    #[link_name = "scm_module_goops"]
    pub static mut scm_module_goops: SCM;
}
extern "C" {
    pub fn scm_goops_version() -> SCM;
}
extern "C" {
    pub fn scm_load_goops();
}
extern "C" {
    pub fn scm_make_extended_class(type_name: *const ::std::os::raw::c_char,
                                   applicablep: ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_make_port_classes(ptob: *mut scm_t_port_type);
}
extern "C" {
    pub fn scm_ensure_accessor(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_of(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_standard_class(meta: SCM, name: SCM, dsupers: SCM,
                                   dslots: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_ref(obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_set_x(obj: SCM, slot_name: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_inherit_applicable(c: SCM);
}
extern "C" {
    pub fn scm_instance_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_generic(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_is_method(x: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_class_name(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_direct_supers(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_direct_slots(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_direct_subclasses(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_direct_methods(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_precedence_list(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_class_slots(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generic_function_name(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generic_function_methods(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_method_generic_function(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_method_specializers(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_method_procedure(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_bound_p(obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_exists_p(obj: SCM, slot_name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_modify_instance(old: SCM, newinst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_modify_class(old: SCM, newcls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_generic_capability_p(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_enable_primitive_generic_x(subrs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_primitive_generic_x(subr: SCM, generic: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_generic_generic(subr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_change_object_class(arg1: SCM, arg2: SCM, arg3: SCM);
}
extern "C" {
    pub fn scm_wta_dispatch_0(gf: SCM, subr: *const ::std::os::raw::c_char)
     -> SCM;
}
extern "C" {
    pub fn scm_wta_dispatch_1(gf: SCM, a1: SCM, pos: ::std::os::raw::c_int,
                              subr: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_wta_dispatch_2(gf: SCM, a1: SCM, a2: SCM,
                              pos: ::std::os::raw::c_int,
                              subr: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_wta_dispatch_n(gf: SCM, args: SCM, pos: ::std::os::raw::c_int,
                              subr: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_i_define_class_for_vtable(vtable: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_goops();
}
extern "C" {
    pub fn scm_i_primitive_code_p(code: *const scm_t_uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_primitive_call_ip(subr: SCM) -> scm_t_uintptr;
}
extern "C" {
    pub fn scm_apply_subr(sp: *mut scm_vm_stack_element, nargs: scm_t_ptrdiff)
     -> SCM;
}
extern "C" {
    pub fn scm_c_make_gsubr(name: *const ::std::os::raw::c_char,
                            req: ::std::os::raw::c_int,
                            opt: ::std::os::raw::c_int,
                            rst: ::std::os::raw::c_int, fcn: scm_t_subr)
     -> SCM;
}
extern "C" {
    pub fn scm_c_make_gsubr_with_generic(name: *const ::std::os::raw::c_char,
                                         req: ::std::os::raw::c_int,
                                         opt: ::std::os::raw::c_int,
                                         rst: ::std::os::raw::c_int,
                                         fcn: scm_t_subr, gf: *mut SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_c_define_gsubr(name: *const ::std::os::raw::c_char,
                              req: ::std::os::raw::c_int,
                              opt: ::std::os::raw::c_int,
                              rst: ::std::os::raw::c_int, fcn: scm_t_subr)
     -> SCM;
}
extern "C" {
    pub fn scm_c_define_gsubr_with_generic(name:
                                               *const ::std::os::raw::c_char,
                                           req: ::std::os::raw::c_int,
                                           opt: ::std::os::raw::c_int,
                                           rst: ::std::os::raw::c_int,
                                           fcn: scm_t_subr, gf: *mut SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_init_gsubr();
}
extern "C" {
    pub fn scm_make_guardian() -> SCM;
}
extern "C" {
    pub fn scm_i_init_guardians_for_gc();
}
extern "C" {
    pub fn scm_i_identify_inaccessible_guardeds();
}
extern "C" {
    pub fn scm_i_mark_inaccessible_guardeds() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_guardians();
}
extern "C" {
    pub fn scm_i_locale_string_hash(str: *const ::std::os::raw::c_char,
                                    len: usize) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_latin1_string_hash(str: *const ::std::os::raw::c_char,
                                    len: usize) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_utf8_string_hash(str: *const ::std::os::raw::c_char,
                                  len: usize) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_i_string_hash(str: SCM) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_ihashq(obj: SCM, n: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_hashq(obj: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ihashv(obj: SCM, n: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_hashv(obj: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ihash(obj: SCM, n: ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_hash(obj: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_hash();
}
pub type scm_t_hash_fn =
    ::std::option::Option<unsafe extern "C" fn(obj: SCM,
                                               max: ::std::os::raw::c_ulong,
                                               closure:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_ulong>;
pub type scm_t_assoc_fn =
    ::std::option::Option<unsafe extern "C" fn(obj: SCM, alist: SCM,
                                               closure:
                                                   *mut ::std::os::raw::c_void)
                              -> SCM>;
pub type scm_t_hash_fold_fn =
    ::std::option::Option<unsafe extern "C" fn(closure:
                                                   *mut ::std::os::raw::c_void,
                                               key: SCM, value: SCM,
                                               result: SCM) -> SCM>;
pub type scm_t_hash_handle_fn =
    ::std::option::Option<unsafe extern "C" fn(closure:
                                                   *mut ::std::os::raw::c_void,
                                               handle: SCM) -> SCM>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_hashtable {
    pub n_items: ::std::os::raw::c_ulong,
    pub lower: ::std::os::raw::c_ulong,
    pub upper: ::std::os::raw::c_ulong,
    pub size_index: ::std::os::raw::c_int,
    pub min_size_index: ::std::os::raw::c_int,
    pub hash_fn: scm_t_hash_fn,
}
#[test]
fn bindgen_test_layout_scm_t_hashtable() {
    assert_eq!(::std::mem::size_of::<scm_t_hashtable>() , 40usize , concat ! (
               "Size of: " , stringify ! ( scm_t_hashtable ) ));
    assert_eq! (::std::mem::align_of::<scm_t_hashtable>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( scm_t_hashtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_hashtable ) ) . n_items as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_hashtable ) ,
                "::" , stringify ! ( n_items ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_hashtable ) ) . lower as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_hashtable ) ,
                "::" , stringify ! ( lower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_hashtable ) ) . upper as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_hashtable ) ,
                "::" , stringify ! ( upper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_hashtable ) ) . size_index as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_hashtable ) ,
                "::" , stringify ! ( size_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_hashtable ) ) . min_size_index as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_hashtable ) ,
                "::" , stringify ! ( min_size_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_hashtable ) ) . hash_fn as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_hashtable ) ,
                "::" , stringify ! ( hash_fn ) ));
}
impl Clone for scm_t_hashtable {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn scm_vector_to_hash_table(vector: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_make_hash_table(k: ::std::os::raw::c_ulong) -> SCM;
}
extern "C" {
    pub fn scm_make_hash_table(n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_rehash(table: SCM, hash_fn: scm_t_hash_fn,
                        closure: *mut ::std::os::raw::c_void,
                        func_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_hash_fn_get_handle(table: SCM, obj: SCM,
                                  hash_fn: scm_t_hash_fn,
                                  assoc_fn: scm_t_assoc_fn,
                                  closure: *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_create_handle_x(table: SCM, obj: SCM, init: SCM,
                                       hash_fn: scm_t_hash_fn,
                                       assoc_fn: scm_t_assoc_fn,
                                       closure: *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_ref(table: SCM, obj: SCM, dflt: SCM,
                           hash_fn: scm_t_hash_fn, assoc_fn: scm_t_assoc_fn,
                           closure: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_set_x(table: SCM, obj: SCM, val: SCM,
                             hash_fn: scm_t_hash_fn, assoc_fn: scm_t_assoc_fn,
                             closure: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_hash_fn_remove_x(table: SCM, obj: SCM, hash_fn: scm_t_hash_fn,
                                assoc_fn: scm_t_assoc_fn,
                                closure: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_internal_hash_fold(fn_: scm_t_hash_fold_fn,
                                  closure: *mut ::std::os::raw::c_void,
                                  init: SCM, table: SCM) -> SCM;
}
extern "C" {
    pub fn scm_internal_hash_for_each_handle(fn_: scm_t_hash_handle_fn,
                                             closure:
                                                 *mut ::std::os::raw::c_void,
                                             table: SCM);
}
extern "C" {
    pub fn scm_hash_clear_x(table: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_get_handle(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_create_handle_x(table: SCM, obj: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_ref(table: SCM, obj: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_set_x(table: SCM, obj: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashq_remove_x(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_get_handle(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_create_handle_x(table: SCM, obj: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_ref(table: SCM, obj: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_set_x(table: SCM, obj: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashv_remove_x(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_get_handle(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_create_handle_x(table: SCM, obj: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_ref(table: SCM, obj: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_set_x(table: SCM, obj: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_remove_x(table: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashx_get_handle(hash: SCM, assoc: SCM, table: SCM, obj: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_hashx_create_handle_x(hash: SCM, assoc: SCM, table: SCM,
                                     obj: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashx_ref(hash: SCM, assoc: SCM, table: SCM, obj: SCM,
                         dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashx_set_x(hash: SCM, assoc: SCM, table: SCM, obj: SCM,
                           val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hashx_remove_x(hash: SCM, assoc: SCM, table: SCM, obj: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_hash_fold(proc_: SCM, init: SCM, hash: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_for_each(proc_: SCM, hash: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_for_each_handle(proc_: SCM, hash: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_map_to_list(proc_: SCM, hash: SCM) -> SCM;
}
extern "C" {
    pub fn scm_hash_count(hash: SCM, pred: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_hashtable_print(exp: SCM, port: SCM,
                                 pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_hashtab();
}
extern "C" {
    #[link_name = "scm_global_locale"]
    pub static mut scm_global_locale: SCM;
}
extern "C" {
    pub fn scm_make_locale(category_mask: SCM, locale_name: SCM,
                           base_locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_locale_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_lt(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_gt(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_ci_lt(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_ci_gt(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_ci_eq(s1: SCM, s2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_lt(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_gt(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_ci_lt(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_ci_gt(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_ci_eq(c1: SCM, c2: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_upcase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_downcase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_locale_titlecase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_upcase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_downcase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_locale_titlecase(chr: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_locale_string_to_integer(str: SCM, base: SCM, locale: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_locale_string_to_inexact(str: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_nl_langinfo(item: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_i18n();
}
extern "C" {
    pub fn scm_bootstrap_i18n();
}
extern "C" {
    #[link_name = "scm_i_init_mutex"]
    pub static mut scm_i_init_mutex: pthread_mutex_t;
}
extern "C" {
    #[link_name = "scm_initialized_p"]
    pub static mut scm_initialized_p: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_guile();
}
extern "C" {
    pub fn scm_boot_guile(argc: ::std::os::raw::c_int,
                          argv: *mut *mut ::std::os::raw::c_char,
                          main_func:
                              ::std::option::Option<unsafe extern "C" fn(closure:
                                                                             *mut ::std::os::raw::c_void,
                                                                         argc:
                                                                             ::std::os::raw::c_int,
                                                                         argv:
                                                                             *mut *mut ::std::os::raw::c_char)>,
                          closure: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_i_init_guile(base: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_load_startup_files();
}
extern "C" {
    pub fn scm_ftell(object: SCM) -> SCM;
}
extern "C" {
    pub fn scm_redirect_port(into_pt: SCM, from_pt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dup_to_fdes(fd_or_port: SCM, newfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dup2(oldfd: SCM, newfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fileno(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_isatty_p(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fdopen(fdes: SCM, modes: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_move_to_fdes(port: SCM, fd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fdes_to_ports(fd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_ioext();
}
extern "C" {
    pub fn scm_read_delimited_x(delims: SCM, buf: SCM, gobble: SCM, port: SCM,
                                offset: SCM, length: SCM) -> SCM;
}
extern "C" {
    pub fn scm_read_line(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_write_line(obj: SCM, port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_rdelim_builtins() -> SCM;
}
extern "C" {
    pub fn scm_init_rdelim();
}
extern "C" {
    pub fn scm_read_string_x_partial(str: SCM, port_or_fdes: SCM, start: SCM,
                                     end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_write_string_partial(str: SCM, port_or_fdes: SCM, start: SCM,
                                    end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_rw_builtins() -> SCM;
}
extern "C" {
    pub fn scm_init_rw();
}
extern "C" {
    pub fn scm_keyword_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_to_keyword(symbol: SCM) -> SCM;
}
extern "C" {
    pub fn scm_keyword_to_symbol(keyword: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_keyword(val: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_from_locale_keyword(name: *const ::std::os::raw::c_char)
     -> SCM;
}
extern "C" {
    pub fn scm_from_locale_keywordn(name: *const ::std::os::raw::c_char,
                                    len: usize) -> SCM;
}
extern "C" {
    pub fn scm_from_latin1_keyword(name: *const ::std::os::raw::c_char)
     -> SCM;
}
extern "C" {
    pub fn scm_from_utf8_keyword(name: *const ::std::os::raw::c_char) -> SCM;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_keyword_arguments_flags {
    SCM_ALLOW_OTHER_KEYS = 1,
    SCM_ALLOW_NON_KEYWORD_ARGUMENTS = 2,
}
pub use self::scm_keyword_arguments_flags as scm_t_keyword_arguments_flags;
extern "C" {
    pub fn scm_c_bind_keyword_arguments(subr: *const ::std::os::raw::c_char,
                                        rest: SCM,
                                        flags:
                                            scm_t_keyword_arguments_flags, ...);
}
extern "C" {
    pub fn scm_init_keywords();
}
extern "C" {
    pub fn scm_list_1(e1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_2(e1: SCM, e2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_3(e1: SCM, e2: SCM, e3: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_4(e1: SCM, e2: SCM, e3: SCM, e4: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_5(e1: SCM, e2: SCM, e3: SCM, e4: SCM, e5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_n(elt: SCM, ...) -> SCM;
}
extern "C" {
    pub fn scm_list(objs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_head(lst: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_list(n: SCM, init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cons_star(arg: SCM, objs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_null_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ilength(sx: SCM) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_length(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_append(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_append_x(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reverse(lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reverse_x(lst: SCM, newtail: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_ref(lst: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_set_x(lst: SCM, k: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_cdr_set_x(lst: SCM, k: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_last_pair(sx: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_tail(lst: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_memq(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memq(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_memv(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_member(x: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delq_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delv_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delete_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_copy(lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delq(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delv(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delete(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delq1_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delv1_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_delete1_x(item: SCM, lst: SCM) -> SCM;
}
extern "C" {
    pub fn scm_filter(pred: SCM, list: SCM) -> SCM;
}
extern "C" {
    pub fn scm_filter_x(pred: SCM, list: SCM) -> SCM;
}
extern "C" {
    pub fn scm_copy_tree(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_finite_list_copy(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_list();
}
extern "C" {
    pub fn scm_parse_path(path: SCM, tail: SCM) -> SCM;
}
extern "C" {
    pub fn scm_parse_path_with_ellipsis(path: SCM, base: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_load(filename: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_primitive_load(filename: *const ::std::os::raw::c_char)
     -> SCM;
}
extern "C" {
    pub fn scm_sys_package_data_dir() -> SCM;
}
extern "C" {
    pub fn scm_sys_library_dir() -> SCM;
}
extern "C" {
    pub fn scm_sys_site_dir() -> SCM;
}
extern "C" {
    pub fn scm_sys_global_site_dir() -> SCM;
}
extern "C" {
    pub fn scm_sys_site_ccache_dir() -> SCM;
}
extern "C" {
    pub fn scm_search_path(path: SCM, filename: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_search_load_path(filename: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_load_path(filename_and_exception_on_not_found: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_c_primitive_load_path(filename: *const ::std::os::raw::c_char)
     -> SCM;
}
extern "C" {
    pub fn scm_sys_warn_auto_compilation_enabled() -> SCM;
}
extern "C" {
    pub fn scm_init_load_path();
}
extern "C" {
    pub fn scm_init_load();
}
extern "C" {
    pub fn scm_init_load_should_auto_compile();
}
extern "C" {
    pub fn scm_init_eval_in_scheme();
}
extern "C" {
    pub fn scm_i_mirror_backslashes(path: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type scm_t_macro_primitive =
    ::std::option::Option<unsafe extern "C" fn(arg1: SCM, arg2: SCM) -> SCM>;
extern "C" {
    pub fn scm_make_syntax_transformer(name_or_existing_definition: SCM,
                                       type_: SCM, binding: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_type(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_name(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_binding(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_macro_transformer(m: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_make_primitive_macro(name: *const ::std::os::raw::c_char,
                                      fn_: scm_t_macro_primitive) -> SCM;
}
extern "C" {
    pub fn scm_i_macro_primitive(m: SCM) -> scm_t_macro_primitive;
}
extern "C" {
    pub fn scm_init_macros();
}
extern "C" {
    #[link_name = "scm_tc16_malloc"]
    pub static mut scm_tc16_malloc: scm_t_bits;
}
extern "C" {
    pub fn scm_malloc_obj(n: usize) -> SCM;
}
extern "C" {
    pub fn scm_init_mallocs();
}
extern "C" {
    #[link_name = "scm_module_system_booted_p"]
    pub static mut scm_module_system_booted_p: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "scm_module_tag"]
    pub static mut scm_module_tag: scm_t_bits;
}
extern "C" {
    pub fn scm_current_module() -> SCM;
}
extern "C" {
    pub fn scm_the_root_module() -> SCM;
}
extern "C" {
    pub fn scm_interaction_environment() -> SCM;
}
extern "C" {
    pub fn scm_set_current_module(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_call_with_current_module(module: SCM,
                                          func:
                                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                             *mut ::std::os::raw::c_void)
                                                                        ->
                                                                            SCM>,
                                          data: *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_dynwind_current_module(module: SCM);
}
extern "C" {
    pub fn scm_module_variable(module: SCM, sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_local_variable(module: SCM, sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_ensure_local_variable(module: SCM, sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_lookup(name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_define(name: *const ::std::os::raw::c_char, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lookup(symbol: SCM) -> SCM;
}
extern "C" {
    pub fn scm_define(symbol: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_module_lookup(module: SCM,
                               name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_module_define(module: SCM,
                               name: *const ::std::os::raw::c_char, val: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_module_lookup(module: SCM, symbol: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_define(module: SCM, symbol: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_export(module: SCM, symbol_list: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_reverse_lookup(module: SCM, variable: SCM) -> SCM;
}
extern "C" {
    pub fn scm_public_variable(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_private_variable(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_public_variable(module_name: *const ::std::os::raw::c_char,
                                 name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_private_variable(module_name: *const ::std::os::raw::c_char,
                                  name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_public_lookup(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_private_lookup(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_public_lookup(module_name: *const ::std::os::raw::c_char,
                               name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_private_lookup(module_name: *const ::std::os::raw::c_char,
                                name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_public_ref(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_private_ref(module_name: SCM, name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_public_ref(module_name: *const ::std::os::raw::c_char,
                            name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_private_ref(module_name: *const ::std::os::raw::c_char,
                             name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_resolve_module(name: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_resolve_module(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_define_module(name: *const ::std::os::raw::c_char,
                               init:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut ::std::os::raw::c_void)>,
                               data: *mut ::std::os::raw::c_void) -> SCM;
}
extern "C" {
    pub fn scm_c_use_module(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_c_export(name: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn scm_module_public_interface(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_import_interface(module: SCM, sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_module_transformer(module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_current_module_transformer() -> SCM;
}
extern "C" {
    pub fn scm_get_pre_modules_obarray() -> SCM;
}
extern "C" {
    pub fn scm_modules_prehistory();
}
extern "C" {
    pub fn scm_init_modules();
}
extern "C" {
    pub fn scm_gethost(host: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getnet(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getproto(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getserv(name: SCM, proto: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sethost(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setnet(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setproto(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setserv(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getaddrinfo(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM,
                           arg5: SCM, arg6: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gai_strerror(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_net_db();
}
extern "C" {
    pub fn scm_object_properties(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_object_properties_x(obj: SCM, plist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_object_property(obj: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_object_property_x(obj: SCM, key: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_objprop();
}
extern "C" {
    pub fn scm_cons2(w: SCM, x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pair_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_car_x(pair: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_cdr_x(pair: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdddar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cddaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdaddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdadar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdaadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cdaaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caddar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_cadaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caaddr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caadar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caaadr(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_caaaar(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_pairs();
}
extern "C" {
    pub fn scm_tcsetpgrp(port: SCM, pgid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tcgetpgrp(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ctermid() -> SCM;
}
extern "C" {
    pub fn scm_setsid() -> SCM;
}
extern "C" {
    pub fn scm_getsid(pid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setpgid(pid: SCM, pgid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pipe() -> SCM;
}
extern "C" {
    pub fn scm_getgroups() -> SCM;
}
extern "C" {
    pub fn scm_setgroups(groups: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getpgrp() -> SCM;
}
extern "C" {
    pub fn scm_getpwuid(user: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setpwent(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getgrgid(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setgrent(arg: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getrlimit(resource: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setrlimit(resource: SCM, soft: SCM, hard: SCM) -> SCM;
}
extern "C" {
    pub fn scm_kill(pid: SCM, sig: SCM) -> SCM;
}
extern "C" {
    pub fn scm_waitpid(pid: SCM, options: SCM) -> SCM;
}
extern "C" {
    pub fn scm_status_exit_val(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_status_term_sig(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_status_stop_sig(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getppid() -> SCM;
}
extern "C" {
    pub fn scm_getuid() -> SCM;
}
extern "C" {
    pub fn scm_getgid() -> SCM;
}
extern "C" {
    pub fn scm_geteuid() -> SCM;
}
extern "C" {
    pub fn scm_getegid() -> SCM;
}
extern "C" {
    pub fn scm_setuid(uid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setgid(gid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_seteuid(euid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setegid(egid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ttyname(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_execl(filename: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_execlp(filename: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_execle(filename: SCM, env: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_fork() -> SCM;
}
extern "C" {
    pub fn scm_uname() -> SCM;
}
extern "C" {
    pub fn scm_environ(env: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tmpnam() -> SCM;
}
extern "C" {
    pub fn scm_mkstemp(tmpl: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tmpfile() -> SCM;
}
extern "C" {
    pub fn scm_open_pipe(pipestr: SCM, modes: SCM) -> SCM;
}
extern "C" {
    pub fn scm_close_pipe(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_system_star(cmds: SCM) -> SCM;
}
extern "C" {
    pub fn scm_utime(pathname: SCM, actime: SCM, modtime: SCM, actimens: SCM,
                     modtimens: SCM, flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_access(path: SCM, how: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getpid() -> SCM;
}
extern "C" {
    pub fn scm_putenv(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setlocale(category: SCM, locale: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mknod(path: SCM, type_: SCM, perms: SCM, dev: SCM) -> SCM;
}
extern "C" {
    pub fn scm_nice(incr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sync() -> SCM;
}
extern "C" {
    pub fn scm_crypt(key: SCM, salt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_chroot(path: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getlogin() -> SCM;
}
extern "C" {
    pub fn scm_getpriority(which: SCM, who: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setpriority(which: SCM, who: SCM, prio: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getpass(prompt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_flock(file: SCM, operation: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sethostname(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gethostname() -> SCM;
}
extern "C" {
    pub fn scm_getaffinity(pid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setaffinity(pid: SCM, cpu_set: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_posix();
}
extern "C" {
    #[link_name = "scm_i_locale_mutex"]
    pub static mut scm_i_locale_mutex: pthread_mutex_t;
}
extern "C" {
    #[link_name = "scm_sym_name"]
    pub static mut scm_sym_name: SCM;
}
extern "C" {
    #[link_name = "scm_sym_system_procedure"]
    pub static mut scm_sym_system_procedure: SCM;
}
extern "C" {
    #[link_name = "scm_sym_documentation"]
    pub static mut scm_sym_documentation: SCM;
}
extern "C" {
    pub fn scm_i_procedure_arity(proc_: SCM, req: *mut ::std::os::raw::c_int,
                                 opt: *mut ::std::os::raw::c_int,
                                 rest: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_set_procedure_minimum_arity_x(proc_: SCM, req: SCM, opt: SCM,
                                             rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_minimum_arity(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_properties(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_procedure_properties_x(proc_: SCM, alist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_property(proc_: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_procedure_property_x(proc_: SCM, key: SCM, val: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_procedure_source(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_name(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_procedure_documentation(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_procprop();
}
extern "C" {
    #[link_name = "scm_tc16_promise"]
    pub static mut scm_tc16_promise: scm_t_bits;
}
extern "C" {
    pub fn scm_make_promise(thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_force(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_promise_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_promises();
}
extern "C" {
    pub fn scm_eof_object() -> SCM;
}
extern "C" {
    pub fn scm_open_bytevector_input_port(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_custom_binary_input_port(arg1: SCM, arg2: SCM, arg3: SCM,
                                             arg4: SCM, arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_u8(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lookahead_u8(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_bytevector_n(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_bytevector_n_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_get_bytevector_some(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_get_bytevector_all(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unget_bytevector(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_put_u8(arg1: SCM, arg2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_put_bytevector(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_open_bytevector_output_port(arg1: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_custom_binary_output_port(arg1: SCM, arg2: SCM, arg3: SCM,
                                              arg4: SCM, arg5: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_custom_binary_input_output_port(arg1: SCM, arg2: SCM,
                                                    arg3: SCM, arg4: SCM,
                                                    arg5: SCM, arg6: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_get_string_n_x(arg1: SCM, arg2: SCM, arg3: SCM, arg4: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_init_r6rs_ports();
}
extern "C" {
    pub fn scm_register_r6rs_ports();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_rstate {
    pub rng: *mut scm_t_rng,
    pub normal_next: f64,
}
#[test]
fn bindgen_test_layout_scm_t_rstate() {
    assert_eq!(::std::mem::size_of::<scm_t_rstate>() , 16usize , concat ! (
               "Size of: " , stringify ! ( scm_t_rstate ) ));
    assert_eq! (::std::mem::align_of::<scm_t_rstate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_rstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_rstate ) ) . rng as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_rstate ) , "::" ,
                stringify ! ( rng ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_rstate ) ) . normal_next as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_rstate ) , "::" ,
                stringify ! ( normal_next ) ));
}
impl Clone for scm_t_rstate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_rng {
    pub rstate_size: usize,
    pub random_bits: ::std::option::Option<unsafe extern "C" fn(state:
                                                                    *mut scm_t_rstate)
                                               -> scm_t_uint32>,
    pub init_rstate: ::std::option::Option<unsafe extern "C" fn(state:
                                                                    *mut scm_t_rstate,
                                                                seed:
                                                                    *const ::std::os::raw::c_char,
                                                                n:
                                                                    ::std::os::raw::c_int)>,
    pub copy_rstate: ::std::option::Option<unsafe extern "C" fn(state:
                                                                    *mut scm_t_rstate)
                                               -> *mut scm_t_rstate>,
    pub from_datum: ::std::option::Option<unsafe extern "C" fn(state:
                                                                   *mut scm_t_rstate,
                                                               datum: SCM)>,
    pub to_datum: ::std::option::Option<unsafe extern "C" fn(state:
                                                                 *mut scm_t_rstate)
                                            -> SCM>,
}
#[test]
fn bindgen_test_layout_scm_t_rng() {
    assert_eq!(::std::mem::size_of::<scm_t_rng>() , 48usize , concat ! (
               "Size of: " , stringify ! ( scm_t_rng ) ));
    assert_eq! (::std::mem::align_of::<scm_t_rng>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_rng ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_rng ) ) . rstate_size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_rng ) , "::" ,
                stringify ! ( rstate_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_rng ) ) . random_bits as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_rng ) , "::" ,
                stringify ! ( random_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_rng ) ) . init_rstate as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_rng ) , "::" ,
                stringify ! ( init_rstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_rng ) ) . copy_rstate as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_rng ) , "::" ,
                stringify ! ( copy_rstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_rng ) ) . from_datum as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_rng ) , "::" ,
                stringify ! ( from_datum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_rng ) ) . to_datum as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_rng ) , "::" ,
                stringify ! ( to_datum ) ));
}
impl Clone for scm_t_rng {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "scm_the_rng"]
    pub static mut scm_the_rng: scm_t_rng;
}
extern "C" {
    pub fn scm_c_make_rstate(arg1: *const ::std::os::raw::c_char,
                             arg2: ::std::os::raw::c_int)
     -> *mut scm_t_rstate;
}
extern "C" {
    pub fn scm_c_rstate_from_datum(datum: SCM) -> *mut scm_t_rstate;
}
extern "C" {
    pub fn scm_c_default_rstate() -> *mut scm_t_rstate;
}
extern "C" {
    pub fn scm_c_uniform01(arg1: *mut scm_t_rstate) -> f64;
}
extern "C" {
    pub fn scm_c_normal01(arg1: *mut scm_t_rstate) -> f64;
}
extern "C" {
    pub fn scm_c_exp1(arg1: *mut scm_t_rstate) -> f64;
}
extern "C" {
    pub fn scm_c_random(arg1: *mut scm_t_rstate, m: scm_t_uint32)
     -> scm_t_uint32;
}
extern "C" {
    pub fn scm_c_random64(state: *mut scm_t_rstate, m: scm_t_uint64)
     -> scm_t_uint64;
}
extern "C" {
    pub fn scm_c_random_bignum(arg1: *mut scm_t_rstate, m: SCM) -> SCM;
}
extern "C" {
    #[link_name = "scm_tc16_rstate"]
    pub static mut scm_tc16_rstate: scm_t_bits;
}
extern "C" {
    #[link_name = "scm_masktab"]
    pub static mut scm_masktab: [::std::os::raw::c_uchar; 256usize];
}
extern "C" {
    #[link_name = "scm_var_random_state"]
    pub static mut scm_var_random_state: SCM;
}
extern "C" {
    pub fn scm_random(n: SCM, state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_copy_random_state(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_seed_to_random_state(seed: SCM) -> SCM;
}
extern "C" {
    pub fn scm_datum_to_random_state(datum: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_state_to_datum(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_state_from_platform() -> SCM;
}
extern "C" {
    pub fn scm_random_uniform(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_solid_sphere_x(v: SCM, state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_hollow_sphere_x(v: SCM, state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_normal(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_normal_vector_x(v: SCM, state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_random_exp(state: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_random();
}
extern "C" {
    pub fn scm_i_random_bytes_from_platform(buf: *mut ::std::os::raw::c_uchar,
                                            len: usize);
}
extern "C" {
    #[link_name = "scm_sym_dot"]
    pub static mut scm_sym_dot: SCM;
}
extern "C" {
    pub fn scm_read_options(setting: SCM) -> SCM;
}
extern "C" {
    pub fn scm_read(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_read_hash_extend(chr: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_scan_for_encoding(port: SCM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_file_encoding(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_input_error(func: *const ::std::os::raw::c_char, port: SCM,
                             message: *const ::std::os::raw::c_char,
                             arg: SCM);
}
extern "C" {
    pub fn scm_init_read();
}
extern "C" {
    pub fn scm_sigaction(signum: SCM, handler: SCM, flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sigaction_for_thread(signum: SCM, handler: SCM, flags: SCM,
                                    thread: SCM) -> SCM;
}
extern "C" {
    pub fn scm_restore_signals() -> SCM;
}
extern "C" {
    pub fn scm_alarm(i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setitimer(which_timer: SCM, interval_seconds: SCM,
                         interval_microseconds: SCM, value_seconds: SCM,
                         value_microseconds: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getitimer(which_timer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_pause() -> SCM;
}
extern "C" {
    pub fn scm_sleep(i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_usleep(i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_raise(sig: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_scmsigs();
}
extern "C" {
    pub fn scm_i_close_signal_pipe();
}
extern "C" {
    pub fn scm_i_ensure_signal_delivery_thread();
}
extern "C" {
    #[link_name = "scm_i_signal_delivery_thread"]
    pub static mut scm_i_signal_delivery_thread: *mut scm_i_thread;
}
extern "C" {
    pub fn scm_find_executable(name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_find_impl_file(exec_path: *mut ::std::os::raw::c_char,
                              generic_name: *const ::std::os::raw::c_char,
                              initname: *const ::std::os::raw::c_char,
                              sep: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_get_meta_args(argc: ::std::os::raw::c_int,
                             argv: *mut *mut ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_count_argv(argv: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_shell_usage(fatal: ::std::os::raw::c_int,
                           message: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_compile_shell_switches(argc: ::std::os::raw::c_int,
                                      argv: *mut *mut ::std::os::raw::c_char)
     -> SCM;
}
extern "C" {
    pub fn scm_shell(argc: ::std::os::raw::c_int,
                     argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "scm_usage_name"]
    pub static mut scm_usage_name: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn scm_i_set_boot_program_arguments(argc: ::std::os::raw::c_int,
                                            argv:
                                                *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn scm_init_script();
}
extern "C" {
    pub fn scm_system(cmd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getenv(nam: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_exit(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive__exit(status: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getenv_int(var: *const ::std::os::raw::c_char,
                          def: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_init_simpos();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_smob_descriptor {
    pub name: *const ::std::os::raw::c_char,
    pub size: usize,
    pub mark: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> SCM>,
    pub free: ::std::option::Option<unsafe extern "C" fn(arg1: SCM) -> usize>,
    pub print: ::std::option::Option<unsafe extern "C" fn(exp: SCM, port: SCM,
                                                          pstate:
                                                              *mut scm_print_state)
                                         -> ::std::os::raw::c_int>,
    pub equalp: ::std::option::Option<unsafe extern "C" fn(arg1: SCM,
                                                           arg2: SCM) -> SCM>,
    pub apply: scm_t_subr,
    pub apply_trampoline: SCM,
}
#[test]
fn bindgen_test_layout_scm_smob_descriptor() {
    assert_eq!(::std::mem::size_of::<scm_smob_descriptor>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( scm_smob_descriptor ) ));
    assert_eq! (::std::mem::align_of::<scm_smob_descriptor>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( scm_smob_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_smob_descriptor ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_smob_descriptor ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_smob_descriptor ) ) . size as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_smob_descriptor ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_smob_descriptor ) ) . mark as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_smob_descriptor ) ,
                "::" , stringify ! ( mark ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_smob_descriptor ) ) . free as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_smob_descriptor ) ,
                "::" , stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_smob_descriptor ) ) . print as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_smob_descriptor ) ,
                "::" , stringify ! ( print ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_smob_descriptor ) ) . equalp as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_smob_descriptor ) ,
                "::" , stringify ! ( equalp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_smob_descriptor ) ) . apply as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_smob_descriptor ) ,
                "::" , stringify ! ( apply ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_smob_descriptor ) ) .
                apply_trampoline as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! ( scm_smob_descriptor ) ,
                "::" , stringify ! ( apply_trampoline ) ));
}
impl Clone for scm_smob_descriptor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "scm_numsmob"]
    pub static mut scm_numsmob: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "scm_smobs"]
    pub static mut scm_smobs: [scm_smob_descriptor; 0usize];
}
extern "C" {
    pub fn scm_i_new_smob(tc: scm_t_bits, arg1: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_i_new_double_smob(tc: scm_t_bits, arg1: scm_t_bits,
                                 arg2: scm_t_bits, arg3: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_mark0(ptr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_markcdr(ptr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_free0(ptr: SCM) -> usize;
}
extern "C" {
    pub fn scm_smob_print(exp: SCM, port: SCM, pstate: *mut scm_print_state)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_make_smob_type(name: *const ::std::os::raw::c_char,
                              size: usize) -> scm_t_bits;
}
extern "C" {
    pub fn scm_set_smob_mark(tc: scm_t_bits,
                             mark:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                SCM)
                                                           -> SCM>);
}
extern "C" {
    pub fn scm_set_smob_free(tc: scm_t_bits,
                             free:
                                 ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                SCM)
                                                           -> usize>);
}
extern "C" {
    pub fn scm_set_smob_print(tc: scm_t_bits,
                              print:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 SCM,
                                                                             arg2:
                                                                                 SCM,
                                                                             arg3:
                                                                                 *mut scm_print_state)
                                                            ->
                                                                ::std::os::raw::c_int>);
}
extern "C" {
    pub fn scm_set_smob_equalp(tc: scm_t_bits,
                               equalp:
                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                  SCM,
                                                                              arg2:
                                                                                  SCM)
                                                             -> SCM>);
}
extern "C" {
    pub fn scm_set_smob_apply(tc: scm_t_bits, apply: scm_t_subr,
                              req: ::std::os::raw::c_uint,
                              opt: ::std::os::raw::c_uint,
                              rst: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn scm_smob_type_class(tc: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_assert_smob_type(tag: scm_t_bits, val: SCM);
}
extern "C" {
    pub fn scm_make_smob(tc: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_smob_prehistory();
}
extern "C" {
    pub fn scm_inet_aton(address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_ntoa(inetid: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_netof(address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lnaof(address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_makeaddr(net: SCM, lna: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_pton(family: SCM, address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_inet_ntop(family: SCM, address: SCM) -> SCM;
}
extern "C" {
    pub fn scm_socket(family: SCM, style: SCM, proto: SCM) -> SCM;
}
extern "C" {
    pub fn scm_socketpair(family: SCM, style: SCM, proto: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getsockopt(sfd: SCM, level: SCM, optname: SCM) -> SCM;
}
extern "C" {
    pub fn scm_setsockopt(sfd: SCM, level: SCM, optname: SCM, value: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_shutdown(sfd: SCM, how: SCM) -> SCM;
}
extern "C" {
    pub fn scm_connect(sockfd: SCM, fam: SCM, address: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_bind(sockfd: SCM, fam: SCM, address: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_listen(sfd: SCM, backlog: SCM) -> SCM;
}
extern "C" {
    pub fn scm_accept4(sockfd: SCM, flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_accept(sockfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getsockname(sockfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_getpeername(sockfd: SCM) -> SCM;
}
extern "C" {
    pub fn scm_recv(sockfd: SCM, buff_or_size: SCM, flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_send(sockfd: SCM, message: SCM, flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_recvfrom(sockfd: SCM, buff_or_size: SCM, flags: SCM,
                        offset: SCM, length: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sendto(sockfd: SCM, message: SCM, fam: SCM, address: SCM,
                      args_and_flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_socket();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn scm_from_sockaddr(address: *const sockaddr,
                             addr_size: ::std::os::raw::c_uint) -> SCM;
}
extern "C" {
    pub fn scm_to_sockaddr(address: SCM, adress_size: *mut usize)
     -> *mut sockaddr;
}
extern "C" {
    pub fn scm_c_make_socket_address(family: SCM, address: SCM, args: SCM,
                                     address_size: *mut usize)
     -> *mut sockaddr;
}
extern "C" {
    pub fn scm_make_socket_address(family: SCM, address: SCM, args: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_restricted_vector_sort_x(vec: SCM, less: SCM, startpos: SCM,
                                        endpos: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sorted_p(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_merge(ls1: SCM, ls2: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_merge_x(ls1: SCM, ls2: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sort(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sort_x(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stable_sort(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stable_sort_x(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sort_list(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sort_list_x(ls: SCM, less: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_sort();
}
extern "C" {
    #[link_name = "scm_tc16_srcprops"]
    pub static mut scm_tc16_srcprops: scm_t_bits;
}
extern "C" {
    #[link_name = "scm_sym_filename"]
    pub static mut scm_sym_filename: SCM;
}
extern "C" {
    #[link_name = "scm_sym_copy"]
    pub static mut scm_sym_copy: SCM;
}
extern "C" {
    #[link_name = "scm_sym_line"]
    pub static mut scm_sym_line: SCM;
}
extern "C" {
    #[link_name = "scm_sym_column"]
    pub static mut scm_sym_column: SCM;
}
extern "C" {
    pub fn scm_supports_source_properties_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_srcprops(line: ::std::os::raw::c_long,
                             col: ::std::os::raw::c_int, fname: SCM,
                             copy: SCM, plist: SCM) -> SCM;
}
extern "C" {
    pub fn scm_source_property(obj: SCM, key: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_source_property_x(obj: SCM, key: SCM, datum: SCM) -> SCM;
}
extern "C" {
    pub fn scm_source_properties(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_set_source_properties_x(obj: SCM, props: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_has_source_properties(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_set_source_properties_x(obj: SCM,
                                         line: ::std::os::raw::c_long,
                                         col: ::std::os::raw::c_int,
                                         fname: SCM);
}
extern "C" {
    pub fn scm_cons_source(xorig: SCM, x: SCM, y: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_srcprop();
}
extern "C" {
    pub fn scm_local_eval(exp: SCM, env: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reverse_lookup(env: SCM, data: SCM) -> SCM;
}
extern "C" {
    pub fn scm_debug_options(setting: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_debug();
}
extern "C" {
    #[link_name = "scm_stack_checking_enabled_p"]
    pub static mut scm_stack_checking_enabled_p: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_stack_size(start: *mut SCM_STACKITEM)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_stack_report();
}
extern "C" {
    pub fn scm_sys_get_stack_size() -> SCM;
}
extern "C" {
    pub fn scm_init_stackchk();
}
extern "C" {
    #[link_name = "scm_c_time_units_per_second"]
    pub static mut scm_c_time_units_per_second: ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_c_get_internal_run_time() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn scm_get_internal_real_time() -> SCM;
}
extern "C" {
    pub fn scm_get_internal_run_time() -> SCM;
}
extern "C" {
    pub fn scm_current_time() -> SCM;
}
extern "C" {
    pub fn scm_gettimeofday() -> SCM;
}
extern "C" {
    pub fn scm_localtime(time: SCM, zone: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gmtime(time: SCM) -> SCM;
}
extern "C" {
    pub fn scm_mktime(sbd_time: SCM, zone: SCM) -> SCM;
}
extern "C" {
    pub fn scm_tzset() -> SCM;
}
extern "C" {
    pub fn scm_times() -> SCM;
}
extern "C" {
    pub fn scm_strftime(format: SCM, stime: SCM) -> SCM;
}
extern "C" {
    pub fn scm_strptime(format: SCM, string: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_stime();
}
extern "C" {
    pub fn scm_string_null_p(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_any(pred: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_every(pred: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_tabulate(proc_: SCM, len: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_list(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_to_list(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_reverse_list_to_string(chrs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_join(ls: SCM, delimiter: SCM, grammar: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_copy(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_copy_x(target: SCM, tstart: SCM, s: SCM, start: SCM,
                             end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_move_x(str1: SCM, start1: SCM, end1: SCM, str2: SCM,
                                start2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_take(s: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_drop(s: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_take_right(s: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_drop_right(s: SCM, n: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_pad(s: SCM, len: SCM, chr: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_pad_right(s: SCM, len: SCM, chr: SCM, start: SCM,
                                end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_trim(s: SCM, char_pred: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_trim_right(s: SCM, char_pred: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_trim_both(s: SCM, char_pred: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_substring_fill_x(str: SCM, chr: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_fill_x(str: SCM, chr: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_compare(s1: SCM, s2: SCM, proc_lt: SCM, proc_eq: SCM,
                              proc_gt: SCM, start1: SCM, end1: SCM,
                              start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_compare_ci(s1: SCM, s2: SCM, proc_lt: SCM, proc_eq: SCM,
                                 proc_gt: SCM, start1: SCM, end1: SCM,
                                 start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_eq(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                         start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_neq(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                          start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_lt(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                         start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_gt(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                         start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_le(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                         start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ge(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                         start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_eq(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                            start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_neq(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                             start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_lt(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                            start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_gt(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                            start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_le(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                            start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_ge(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                            start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_hash(s: SCM, bound: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_substring_hash_ci(s: SCM, bound: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_prefix_length(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                                    start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_prefix_length_ci(s1: SCM, s2: SCM, start1: SCM,
                                       end1: SCM, start2: SCM, end2: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_suffix_length(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                                    start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_suffix_length_ci(s1: SCM, s2: SCM, start1: SCM,
                                       end1: SCM, start2: SCM, end2: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_prefix_p(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                               start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_prefix_ci_p(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                                  start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_suffix_p(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                               start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_suffix_ci_p(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                                  start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_index(s: SCM, char_pred: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_index_right(s: SCM, char_pred: SCM, start: SCM,
                                  end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_rindex(s: SCM, char_pred: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_skip(s: SCM, char_pred: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_skip_right(s: SCM, char_pred: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_count(s: SCM, char_pred: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_contains(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                               start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_contains_ci(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                                  start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_upcase_x(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_upcase(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_upcase_x(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_upcase(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_downcase_x(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_substring_downcase(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_downcase_x(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_downcase(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_titlecase_x(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_titlecase(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_capitalize_x(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_capitalize(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_reverse(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_reverse_x(str: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_append_shared(ls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_concatenate(ls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_concatenate_shared(ls: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_concatenate_reverse(ls: SCM, final_string: SCM,
                                          end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_concatenate_reverse_shared(ls: SCM, final_string: SCM,
                                                 end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_map(proc_: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_map_x(proc_: SCM, s: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_fold(kons: SCM, knil: SCM, s: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_fold_right(kons: SCM, knil: SCM, s: SCM, start: SCM,
                                 end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_unfold(p: SCM, f: SCM, g: SCM, seed: SCM, base: SCM,
                             make_final: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_unfold_right(p: SCM, f: SCM, g: SCM, seed: SCM,
                                   base: SCM, make_final: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_for_each(proc_: SCM, s: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_for_each_index(proc_: SCM, s: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_xsubstring(s: SCM, from: SCM, to: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_xcopy_x(target: SCM, tstart: SCM, s: SCM, sfrom: SCM,
                              sto: SCM, start: SCM, end: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_replace(s1: SCM, s2: SCM, start1: SCM, end1: SCM,
                              start2: SCM, end2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_tokenize(s: SCM, token_char: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_split(s: SCM, char_pred: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_filter(char_pred: SCM, s: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_string_delete(char_pred: SCM, s: SCM, start: SCM, end: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_init_srfi_13();
}
extern "C" {
    pub fn scm_init_srfi_13_14();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_char_range {
    pub lo: scm_t_wchar,
    pub hi: scm_t_wchar,
}
#[test]
fn bindgen_test_layout_scm_t_char_range() {
    assert_eq!(::std::mem::size_of::<scm_t_char_range>() , 8usize , concat ! (
               "Size of: " , stringify ! ( scm_t_char_range ) ));
    assert_eq! (::std::mem::align_of::<scm_t_char_range>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( scm_t_char_range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_char_range ) ) . lo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_char_range ) ,
                "::" , stringify ! ( lo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_char_range ) ) . hi as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_char_range ) ,
                "::" , stringify ! ( hi ) ));
}
impl Clone for scm_t_char_range {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_char_set {
    pub len: usize,
    pub ranges: *mut scm_t_char_range,
}
#[test]
fn bindgen_test_layout_scm_t_char_set() {
    assert_eq!(::std::mem::size_of::<scm_t_char_set>() , 16usize , concat ! (
               "Size of: " , stringify ! ( scm_t_char_set ) ));
    assert_eq! (::std::mem::align_of::<scm_t_char_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( scm_t_char_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_char_set ) ) . len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_char_set ) , "::"
                , stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_char_set ) ) . ranges as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_char_set ) , "::"
                , stringify ! ( ranges ) ));
}
impl Clone for scm_t_char_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_t_char_set_cursor {
    pub range: usize,
    pub n: scm_t_wchar,
}
#[test]
fn bindgen_test_layout_scm_t_char_set_cursor() {
    assert_eq!(::std::mem::size_of::<scm_t_char_set_cursor>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( scm_t_char_set_cursor )
               ));
    assert_eq! (::std::mem::align_of::<scm_t_char_set_cursor>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( scm_t_char_set_cursor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_char_set_cursor ) ) . range as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_char_set_cursor )
                , "::" , stringify ! ( range ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const scm_t_char_set_cursor ) ) . n as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( scm_t_char_set_cursor )
                , "::" , stringify ! ( n ) ));
}
impl Clone for scm_t_char_set_cursor {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "scm_tc16_charset"]
    pub static mut scm_tc16_charset: ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_charset_get(cs: *mut scm_t_char_set, n: scm_t_wchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_charset_set(cs: *mut scm_t_char_set, n: scm_t_wchar);
}
extern "C" {
    pub fn scm_i_charset_unset(cs: *mut scm_t_char_set, n: scm_t_wchar);
}
extern "C" {
    pub fn scm_char_set_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_eq(char_sets: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_leq(char_sets: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_hash(cs: SCM, bound: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_cursor(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_ref(cs: SCM, cursor: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_cursor_next(cs: SCM, cursor: SCM) -> SCM;
}
extern "C" {
    pub fn scm_end_of_char_set_p(cursor: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_fold(kons: SCM, knil: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_unfold(p: SCM, f: SCM, g: SCM, seed: SCM,
                               base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_unfold_x(p: SCM, f: SCM, g: SCM, seed: SCM,
                                 base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_for_each(proc_: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_map(proc_: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_copy(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set(rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_char_set(list: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_char_set_x(list: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_char_set(str: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_char_set_x(str: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_filter(pred: SCM, cs: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_filter_x(pred: SCM, cs: SCM, base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ucs_range_to_char_set(lower: SCM, upper: SCM, error: SCM,
                                     base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_ucs_range_to_char_set_x(lower: SCM, upper: SCM, error: SCM,
                                       base_cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_to_char_set(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_size(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_count(pred: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_to_list(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_to_string(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_contains_p(cs: SCM, ch: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_every(pred: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_any(pred: SCM, cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_adjoin(cs: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_delete(cs: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_adjoin_x(cs: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_delete_x(cs: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_complement(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_union(rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_intersection(rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_difference(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_xor(rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_diff_plus_intersection(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_complement_x(cs: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_union_x(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_intersection_x(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_difference_x(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_xor_x(cs1: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_char_set_diff_plus_intersection_x(cs1: SCM, cs2: SCM,
                                                 rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_sys_char_set_dump(charset: SCM) -> SCM;
}
extern "C" {
    #[link_name = "scm_char_set_lower_case"]
    pub static mut scm_char_set_lower_case: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_upper_case"]
    pub static mut scm_char_set_upper_case: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_title_case"]
    pub static mut scm_char_set_title_case: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_letter"]
    pub static mut scm_char_set_letter: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_digit"]
    pub static mut scm_char_set_digit: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_letter_and_digit"]
    pub static mut scm_char_set_letter_and_digit: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_graphic"]
    pub static mut scm_char_set_graphic: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_printing"]
    pub static mut scm_char_set_printing: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_whitespace"]
    pub static mut scm_char_set_whitespace: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_iso_control"]
    pub static mut scm_char_set_iso_control: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_punctuation"]
    pub static mut scm_char_set_punctuation: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_symbol"]
    pub static mut scm_char_set_symbol: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_hex_digit"]
    pub static mut scm_char_set_hex_digit: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_blank"]
    pub static mut scm_char_set_blank: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_ascii"]
    pub static mut scm_char_set_ascii: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_empty"]
    pub static mut scm_char_set_empty: SCM;
}
extern "C" {
    #[link_name = "scm_char_set_full"]
    pub static mut scm_char_set_full: SCM;
}
extern "C" {
    pub fn scm_init_srfi_14();
}
extern "C" {
    pub fn scm_string_equal_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_equal_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_less_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_leq_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_gr_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_geq_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_less_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_leq_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_gr_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_geq_p(s1: SCM, s2: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_strorder();
}
extern "C" {
    #[link_name = "scm_string_port_type"]
    pub static mut scm_string_port_type: *mut scm_t_port_type;
}
extern "C" {
    pub fn scm_mkstrport(pos: SCM, str: SCM, modes: ::std::os::raw::c_long,
                         caller: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_strport_to_string(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_object_to_string(obj: SCM, printer: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_output_string(proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_input_string(str: SCM, proc_: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open_input_string(str: SCM) -> SCM;
}
extern "C" {
    pub fn scm_open_output_string() -> SCM;
}
extern "C" {
    pub fn scm_get_output_string(port: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_read_string(expr: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_eval_string(expr: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_c_eval_string_in_module(expr: *const ::std::os::raw::c_char,
                                       module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eval_string(string: SCM) -> SCM;
}
extern "C" {
    pub fn scm_eval_string_in_module(string: SCM, module: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_strports();
}
extern "C" {
    pub fn scm_symbol_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_interned_p(sym: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_symbol(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_to_string(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_to_symbol(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_string_ci_to_symbol(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_fref(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_pref(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_fset_x(s: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_pset_x(s: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_symbol_hash(s: SCM) -> SCM;
}
extern "C" {
    pub fn scm_gensym(prefix: SCM) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_symbol(str: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_locale_symboln(str: *const ::std::os::raw::c_char,
                                   len: usize) -> SCM;
}
extern "C" {
    pub fn scm_take_locale_symbol(sym: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_locale_symboln(sym: *mut ::std::os::raw::c_char,
                                   len: usize) -> SCM;
}
extern "C" {
    pub fn scm_from_latin1_symbol(str: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_latin1_symboln(str: *const ::std::os::raw::c_char,
                                   len: usize) -> SCM;
}
extern "C" {
    pub fn scm_take_latin1_symbol(sym: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_latin1_symboln(sym: *mut ::std::os::raw::c_char,
                                   len: usize) -> SCM;
}
extern "C" {
    pub fn scm_from_utf8_symbol(str: *const ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_from_utf8_symboln(str: *const ::std::os::raw::c_char,
                                 len: usize) -> SCM;
}
extern "C" {
    pub fn scm_take_utf8_symbol(sym: *mut ::std::os::raw::c_char) -> SCM;
}
extern "C" {
    pub fn scm_take_utf8_symboln(sym: *mut ::std::os::raw::c_char, len: usize)
     -> SCM;
}
extern "C" {
    pub fn scm_i_hash_symbol(obj: SCM, n: ::std::os::raw::c_ulong,
                             closure: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn scm_symbols_prehistory();
}
extern "C" {
    pub fn scm_init_symbols();
}
extern "C" {
    pub fn scm_init_trees();
}
extern "C" {
    #[link_name = "scm_i_array_element_type_sizes"]
    pub static mut scm_i_array_element_type_sizes: [usize; 0usize];
}
extern "C" {
    pub fn scm_array_handle_uniform_element_size(h: *mut scm_t_array_handle)
     -> usize;
}
extern "C" {
    pub fn scm_array_handle_uniform_element_bit_size(h:
                                                         *mut scm_t_array_handle)
     -> usize;
}
extern "C" {
    pub fn scm_array_handle_uniform_elements(h: *mut scm_t_array_handle)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_array_handle_uniform_writable_elements(h:
                                                          *mut scm_t_array_handle)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn scm_init_uniform();
}
extern "C" {
    #[link_name = "scm_values_vtable"]
    pub static mut scm_values_vtable: SCM;
}
extern "C" {
    pub fn scm_i_extract_values_2(obj: SCM, p1: *mut SCM, p2: *mut SCM);
}
extern "C" {
    pub fn scm_values(args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_values(base: *mut SCM, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_c_nvalues(obj: SCM) -> usize;
}
extern "C" {
    pub fn scm_c_value_ref(obj: SCM, idx: usize) -> SCM;
}
extern "C" {
    pub fn scm_init_values();
}
extern "C" {
    pub fn scm_make_variable(init: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_undefined_variable() -> SCM;
}
extern "C" {
    pub fn scm_variable_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_variable_ref(var: SCM) -> SCM;
}
extern "C" {
    pub fn scm_variable_set_x(var: SCM, val: SCM) -> SCM;
}
extern "C" {
    pub fn scm_variable_unset_x(var: SCM) -> SCM;
}
extern "C" {
    pub fn scm_variable_bound_p(var: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_variable_print(var: SCM, port: SCM,
                                pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_variable();
}
extern "C" {
    pub fn scm_make_srfi_4_vector(type_: SCM, len: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_u8vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_u8vector(data: *mut scm_t_uint8, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_u8vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u8vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_u8vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_u8vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_u8_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_uint8;
}
extern "C" {
    pub fn scm_array_handle_u8_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_uint8;
}
extern "C" {
    pub fn scm_u8vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                 lenp: *mut usize, incp: *mut isize)
     -> *const scm_t_uint8;
}
extern "C" {
    pub fn scm_u8vector_writable_elements(uvec: SCM,
                                          h: *mut scm_t_array_handle,
                                          lenp: *mut usize, incp: *mut isize)
     -> *mut scm_t_uint8;
}
extern "C" {
    pub fn scm_s8vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_s8vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_s8vector(data: *mut scm_t_int8, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_s8vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s8vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s8vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s8vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s8vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_s8vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_s8vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_s8_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_int8;
}
extern "C" {
    pub fn scm_array_handle_s8_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_int8;
}
extern "C" {
    pub fn scm_s8vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                 lenp: *mut usize, incp: *mut isize)
     -> *const scm_t_int8;
}
extern "C" {
    pub fn scm_s8vector_writable_elements(uvec: SCM,
                                          h: *mut scm_t_array_handle,
                                          lenp: *mut usize, incp: *mut isize)
     -> *mut scm_t_int8;
}
extern "C" {
    pub fn scm_u16vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_u16vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_u16vector(data: *mut scm_t_uint16, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_u16vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u16vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u16vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u16vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u16vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_u16vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_u16vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_u16_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_uint16;
}
extern "C" {
    pub fn scm_array_handle_u16_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_uint16;
}
extern "C" {
    pub fn scm_u16vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const scm_t_uint16;
}
extern "C" {
    pub fn scm_u16vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut scm_t_uint16;
}
extern "C" {
    pub fn scm_s16vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_s16vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_s16vector(data: *mut scm_t_int16, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_s16vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s16vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s16vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s16vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s16vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_s16vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_s16vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_s16_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_int16;
}
extern "C" {
    pub fn scm_array_handle_s16_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_int16;
}
extern "C" {
    pub fn scm_s16vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const scm_t_int16;
}
extern "C" {
    pub fn scm_s16vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut scm_t_int16;
}
extern "C" {
    pub fn scm_u32vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_u32vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_u32vector(data: *mut scm_t_uint32, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_u32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u32vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u32vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u32vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u32vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_u32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_u32vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_u32_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_uint32;
}
extern "C" {
    pub fn scm_array_handle_u32_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_u32vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const scm_t_uint32;
}
extern "C" {
    pub fn scm_u32vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut scm_t_uint32;
}
extern "C" {
    pub fn scm_s32vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_s32vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_s32vector(data: *mut scm_t_int32, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_s32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s32vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s32vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s32vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s32vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_s32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_s32vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_s32_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_int32;
}
extern "C" {
    pub fn scm_array_handle_s32_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_int32;
}
extern "C" {
    pub fn scm_s32vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const scm_t_int32;
}
extern "C" {
    pub fn scm_s32vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut scm_t_int32;
}
extern "C" {
    pub fn scm_u64vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_u64vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_u64vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_u64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_u64vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_u64vector(data: *mut scm_t_uint64, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_u64_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_uint64;
}
extern "C" {
    pub fn scm_array_handle_u64_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_uint64;
}
extern "C" {
    pub fn scm_u64vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const scm_t_uint64;
}
extern "C" {
    pub fn scm_u64vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut scm_t_uint64;
}
extern "C" {
    pub fn scm_s64vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_s64vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_s64vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_s64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_s64vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_s64vector(data: *mut scm_t_int64, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_s64_elements(h: *mut scm_t_array_handle)
     -> *const scm_t_int64;
}
extern "C" {
    pub fn scm_array_handle_s64_writable_elements(h: *mut scm_t_array_handle)
     -> *mut scm_t_int64;
}
extern "C" {
    pub fn scm_s64vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const scm_t_int64;
}
extern "C" {
    pub fn scm_s64vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut scm_t_int64;
}
extern "C" {
    pub fn scm_f32vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_f32vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_f32vector(data: *mut f32, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_f32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f32vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f32vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f32vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f32vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_f32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_f32vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_f32_elements(h: *mut scm_t_array_handle)
     -> *const f32;
}
extern "C" {
    pub fn scm_array_handle_f32_writable_elements(h: *mut scm_t_array_handle)
     -> *mut f32;
}
extern "C" {
    pub fn scm_f32vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const f32;
}
extern "C" {
    pub fn scm_f32vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut f32;
}
extern "C" {
    pub fn scm_f64vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_f64vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_f64vector(data: *mut f64, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_f64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f64vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f64vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f64vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_f64vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_f64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_f64vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_f64_elements(h: *mut scm_t_array_handle)
     -> *const f64;
}
extern "C" {
    pub fn scm_array_handle_f64_writable_elements(h: *mut scm_t_array_handle)
     -> *mut f64;
}
extern "C" {
    pub fn scm_f64vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const f64;
}
extern "C" {
    pub fn scm_f64vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut f64;
}
extern "C" {
    pub fn scm_c32vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_c32vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_c32vector(data: *mut f32, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_c32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c32vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c32vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c32vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c32vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_c32vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_c32vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_c32_elements(h: *mut scm_t_array_handle)
     -> *const f32;
}
extern "C" {
    pub fn scm_array_handle_c32_writable_elements(h: *mut scm_t_array_handle)
     -> *mut f32;
}
extern "C" {
    pub fn scm_c32vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const f32;
}
extern "C" {
    pub fn scm_c32vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut f32;
}
extern "C" {
    pub fn scm_c64vector_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_c64vector(n: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_take_c64vector(data: *mut f64, n: usize) -> SCM;
}
extern "C" {
    pub fn scm_c64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c64vector_length(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c64vector_ref(uvec: SCM, index: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c64vector_set_x(uvec: SCM, index: SCM, value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c64vector_to_list(uvec: SCM) -> SCM;
}
extern "C" {
    pub fn scm_list_to_c64vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_any_to_c64vector(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_array_handle_c64_elements(h: *mut scm_t_array_handle)
     -> *const f64;
}
extern "C" {
    pub fn scm_array_handle_c64_writable_elements(h: *mut scm_t_array_handle)
     -> *mut f64;
}
extern "C" {
    pub fn scm_c64vector_elements(uvec: SCM, h: *mut scm_t_array_handle,
                                  lenp: *mut usize, incp: *mut isize)
     -> *const f64;
}
extern "C" {
    pub fn scm_c64vector_writable_elements(uvec: SCM,
                                           h: *mut scm_t_array_handle,
                                           lenp: *mut usize, incp: *mut isize)
     -> *mut f64;
}
extern "C" {
    pub fn scm_init_srfi_4();
}
extern "C" {
    pub fn scm_major_version() -> SCM;
}
extern "C" {
    pub fn scm_minor_version() -> SCM;
}
extern "C" {
    pub fn scm_micro_version() -> SCM;
}
extern "C" {
    pub fn scm_effective_version() -> SCM;
}
extern "C" {
    pub fn scm_version() -> SCM;
}
extern "C" {
    pub fn scm_init_version();
}
extern "C" {
    pub fn scm_make_soft_port(pv: SCM, modes: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_vports();
}
pub type scm_t_set_predicate_fn =
    ::std::option::Option<unsafe extern "C" fn(obj: SCM,
                                               closure:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type scm_t_set_fold_fn =
    ::std::option::Option<unsafe extern "C" fn(closure:
                                                   *mut ::std::os::raw::c_void,
                                               key: SCM, result: SCM) -> SCM>;
extern "C" {
    pub fn scm_c_make_weak_set(k: ::std::os::raw::c_ulong) -> SCM;
}
extern "C" {
    pub fn scm_weak_set_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_weak_set_lookup(set: SCM, raw_hash: ::std::os::raw::c_ulong,
                                 pred: scm_t_set_predicate_fn,
                                 closure: *mut ::std::os::raw::c_void,
                                 dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_weak_set_add_x(set: SCM, raw_hash: ::std::os::raw::c_ulong,
                                pred: scm_t_set_predicate_fn,
                                closure: *mut ::std::os::raw::c_void,
                                obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_weak_set_remove_x(set: SCM,
                                   raw_hash: ::std::os::raw::c_ulong,
                                   pred: scm_t_set_predicate_fn,
                                   closure: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_weak_set_add_x(set: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_set_remove_x(set: SCM, obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_set_clear_x(set: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_weak_set_fold(proc_: scm_t_set_fold_fn,
                               closure: *mut ::std::os::raw::c_void,
                               init: SCM, set: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_set_fold(proc_: SCM, init: SCM, set: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_set_for_each(proc_: SCM, set: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_set_map_to_list(proc_: SCM, set: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_weak_set_print(exp: SCM, port: SCM,
                                pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_weak_set();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum scm_t_weak_table_kind {
    SCM_WEAK_TABLE_KIND_KEY = 0,
    SCM_WEAK_TABLE_KIND_VALUE = 1,
    SCM_WEAK_TABLE_KIND_BOTH = 2,
}
pub type scm_t_table_predicate_fn =
    ::std::option::Option<unsafe extern "C" fn(k: SCM, v: SCM,
                                               closure:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type scm_t_table_fold_fn =
    ::std::option::Option<unsafe extern "C" fn(closure:
                                                   *mut ::std::os::raw::c_void,
                                               k: SCM, v: SCM, result: SCM)
                              -> SCM>;
extern "C" {
    pub fn scm_c_make_weak_table(k: ::std::os::raw::c_ulong,
                                 kind: scm_t_weak_table_kind) -> SCM;
}
extern "C" {
    pub fn scm_weak_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_weak_table_ref(table: SCM, raw_hash: ::std::os::raw::c_ulong,
                                pred: scm_t_table_predicate_fn,
                                closure: *mut ::std::os::raw::c_void,
                                dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_weak_table_put_x(table: SCM,
                                  raw_hash: ::std::os::raw::c_ulong,
                                  pred: scm_t_table_predicate_fn,
                                  closure: *mut ::std::os::raw::c_void,
                                  key: SCM, value: SCM);
}
extern "C" {
    pub fn scm_c_weak_table_remove_x(table: SCM,
                                     raw_hash: ::std::os::raw::c_ulong,
                                     pred: scm_t_table_predicate_fn,
                                     closure: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn scm_weak_table_refq(table: SCM, key: SCM, dflt: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_table_putq_x(table: SCM, key: SCM, value: SCM);
}
extern "C" {
    pub fn scm_weak_table_remq_x(table: SCM, key: SCM);
}
extern "C" {
    pub fn scm_weak_table_clear_x(table: SCM);
}
extern "C" {
    pub fn scm_c_weak_table_fold(proc_: scm_t_table_fold_fn,
                                 closure: *mut ::std::os::raw::c_void,
                                 init: SCM, table: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_table_fold(proc_: SCM, init: SCM, table: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_table_for_each(proc_: SCM, table: SCM);
}
extern "C" {
    pub fn scm_weak_table_map_to_list(proc_: SCM, table: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_weak_key_hash_table(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_weak_value_hash_table(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_doubly_weak_hash_table(k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_key_hash_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_value_hash_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_doubly_weak_hash_table_p(h: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_weak_table_print(exp: SCM, port: SCM,
                                  pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_weak_table_prehistory();
}
extern "C" {
    pub fn scm_init_weak_table();
}
extern "C" {
    pub fn scm_make_weak_vector(len: SCM, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector_p(x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector_length(v: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector_ref(v: SCM, k: SCM) -> SCM;
}
extern "C" {
    pub fn scm_weak_vector_set_x(v: SCM, k: SCM, x: SCM) -> SCM;
}
extern "C" {
    pub fn scm_c_make_weak_vector(len: usize, fill: SCM) -> SCM;
}
extern "C" {
    pub fn scm_is_weak_vector(obj: SCM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_c_weak_vector_length(vec: SCM) -> usize;
}
extern "C" {
    pub fn scm_c_weak_vector_ref(v: SCM, k: usize) -> SCM;
}
extern "C" {
    pub fn scm_c_weak_vector_set_x(v: SCM, k: usize, x: SCM);
}
extern "C" {
    pub fn scm_init_weak_vectors();
}
extern "C" {
    pub fn scm_print_exception(port: SCM, frame: SCM, key: SCM, args: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_display_error_message(message: SCM, args: SCM, port: SCM);
}
extern "C" {
    pub fn scm_i_display_error(frame: SCM, port: SCM, subr: SCM, message: SCM,
                               args: SCM, rest: SCM);
}
extern "C" {
    pub fn scm_display_error(frame: SCM, port: SCM, subr: SCM, message: SCM,
                             args: SCM, rest: SCM) -> SCM;
}
extern "C" {
    pub fn scm_display_application(frame: SCM, port: SCM, indent: SCM) -> SCM;
}
extern "C" {
    pub fn scm_display_backtrace(stack: SCM, port: SCM, first: SCM,
                                 depth: SCM) -> SCM;
}
extern "C" {
    pub fn scm_display_backtrace_with_highlights(stack: SCM, port: SCM,
                                                 first: SCM, depth: SCM,
                                                 highlights: SCM) -> SCM;
}
extern "C" {
    pub fn scm_backtrace() -> SCM;
}
extern "C" {
    pub fn scm_backtrace_with_highlights(highlights: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_backtrace();
}
extern "C" {
    pub fn scm_program_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_code(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_code_p(code: SCM) -> SCM;
}
extern "C" {
    pub fn scm_primitive_call_ip(prim: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_program_name(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_program_documentation(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_program_properties(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_find_source_for_addr(ip: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_address_range(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_num_free_variables(program: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_free_variable_ref(program: SCM, i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_program_free_variable_set_x(program: SCM, i: SCM, x: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_i_program_arity(program: SCM, req: *mut ::std::os::raw::c_int,
                               opt: *mut ::std::os::raw::c_int,
                               rest: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_program_print(program: SCM, port: SCM,
                               pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_bootstrap_programs();
}
extern "C" {
    pub fn scm_init_programs();
}
extern "C" {
    pub fn scm_frame_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_procedure_name(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_call_representation(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_arguments(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_source(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_address(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_stack_pointer(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_instruction_pointer(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_return_address(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_dynamic_link(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_frame_previous(frame: SCM) -> SCM;
}
extern "C" {
    pub fn scm_i_frame_print(frame: SCM, port: SCM,
                             pstate: *mut scm_print_state);
}
extern "C" {
    pub fn scm_init_frames();
}
extern "C" {
    #[link_name = "scm_stack_type"]
    pub static mut scm_stack_type: SCM;
}
extern "C" {
    pub fn scm_stack_p(obj: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_stack(obj: SCM, args: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stack_id(stack: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stack_ref(stack: SCM, i: SCM) -> SCM;
}
extern "C" {
    pub fn scm_stack_length(stack: SCM) -> SCM;
}
extern "C" {
    pub fn scm_init_stacks();
}
pub type scm_t_inner =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> SCM>;
extern "C" {
    pub fn scm_internal_dynamic_wind(before: scm_t_guard, inner: scm_t_inner,
                                     after: scm_t_guard,
                                     inner_data: *mut ::std::os::raw::c_void,
                                     guard_data: *mut ::std::os::raw::c_void)
     -> SCM;
}
extern "C" {
    pub fn scm_immutable_cell(car: scm_t_bits, cdr: scm_t_bits) -> SCM;
}
extern "C" {
    pub fn scm_immutable_double_cell(car: scm_t_bits, cbr: scm_t_bits,
                                     ccr: scm_t_bits, cdr: scm_t_bits) -> SCM;
}
extern "C" {
    #[link_name = "scm_memory_alloc_key"]
    pub static mut scm_memory_alloc_key: SCM;
}
extern "C" {
    pub fn scm_memory_error(subr: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "scm_no_applicable_method"]
    pub static mut scm_no_applicable_method: SCM;
}
extern "C" {
    #[link_name = "scm_class_boolean"]
    pub static mut scm_class_boolean: SCM;
}
extern "C" {
    #[link_name = "scm_class_char"]
    pub static mut scm_class_char: SCM;
}
extern "C" {
    #[link_name = "scm_class_pair"]
    pub static mut scm_class_pair: SCM;
}
extern "C" {
    #[link_name = "scm_class_procedure"]
    pub static mut scm_class_procedure: SCM;
}
extern "C" {
    #[link_name = "scm_class_string"]
    pub static mut scm_class_string: SCM;
}
extern "C" {
    #[link_name = "scm_class_symbol"]
    pub static mut scm_class_symbol: SCM;
}
extern "C" {
    #[link_name = "scm_class_primitive_generic"]
    pub static mut scm_class_primitive_generic: SCM;
}
extern "C" {
    #[link_name = "scm_class_vector"]
    pub static mut scm_class_vector: SCM;
}
extern "C" {
    #[link_name = "scm_class_null"]
    pub static mut scm_class_null: SCM;
}
extern "C" {
    #[link_name = "scm_class_real"]
    pub static mut scm_class_real: SCM;
}
extern "C" {
    #[link_name = "scm_class_complex"]
    pub static mut scm_class_complex: SCM;
}
extern "C" {
    #[link_name = "scm_class_integer"]
    pub static mut scm_class_integer: SCM;
}
extern "C" {
    #[link_name = "scm_class_fraction"]
    pub static mut scm_class_fraction: SCM;
}
extern "C" {
    #[link_name = "scm_class_unknown"]
    pub static mut scm_class_unknown: SCM;
}
extern "C" {
    #[link_name = "scm_class_top"]
    pub static mut scm_class_top: SCM;
}
extern "C" {
    #[link_name = "scm_class_object"]
    pub static mut scm_class_object: SCM;
}
extern "C" {
    #[link_name = "scm_class_class"]
    pub static mut scm_class_class: SCM;
}
extern "C" {
    #[link_name = "scm_class_applicable"]
    pub static mut scm_class_applicable: SCM;
}
extern "C" {
    #[link_name = "scm_class_applicable_struct"]
    pub static mut scm_class_applicable_struct: SCM;
}
extern "C" {
    #[link_name = "scm_class_applicable_struct_with_setter"]
    pub static mut scm_class_applicable_struct_with_setter: SCM;
}
extern "C" {
    #[link_name = "scm_class_generic"]
    pub static mut scm_class_generic: SCM;
}
extern "C" {
    #[link_name = "scm_class_generic_with_setter"]
    pub static mut scm_class_generic_with_setter: SCM;
}
extern "C" {
    #[link_name = "scm_class_accessor"]
    pub static mut scm_class_accessor: SCM;
}
extern "C" {
    #[link_name = "scm_class_extended_generic"]
    pub static mut scm_class_extended_generic: SCM;
}
extern "C" {
    #[link_name = "scm_class_extended_generic_with_setter"]
    pub static mut scm_class_extended_generic_with_setter: SCM;
}
extern "C" {
    #[link_name = "scm_class_extended_accessor"]
    pub static mut scm_class_extended_accessor: SCM;
}
extern "C" {
    #[link_name = "scm_class_method"]
    pub static mut scm_class_method: SCM;
}
extern "C" {
    #[link_name = "scm_class_accessor_method"]
    pub static mut scm_class_accessor_method: SCM;
}
extern "C" {
    #[link_name = "scm_class_procedure_class"]
    pub static mut scm_class_procedure_class: SCM;
}
extern "C" {
    #[link_name = "scm_class_applicable_struct_class"]
    pub static mut scm_class_applicable_struct_class: SCM;
}
extern "C" {
    #[link_name = "scm_class_number"]
    pub static mut scm_class_number: SCM;
}
extern "C" {
    #[link_name = "scm_class_list"]
    pub static mut scm_class_list: SCM;
}
extern "C" {
    #[link_name = "scm_class_keyword"]
    pub static mut scm_class_keyword: SCM;
}
extern "C" {
    #[link_name = "scm_class_port"]
    pub static mut scm_class_port: SCM;
}
extern "C" {
    #[link_name = "scm_class_input_output_port"]
    pub static mut scm_class_input_output_port: SCM;
}
extern "C" {
    #[link_name = "scm_class_input_port"]
    pub static mut scm_class_input_port: SCM;
}
extern "C" {
    #[link_name = "scm_class_output_port"]
    pub static mut scm_class_output_port: SCM;
}
extern "C" {
    #[link_name = "scm_class_foreign_slot"]
    pub static mut scm_class_foreign_slot: SCM;
}
extern "C" {
    #[link_name = "scm_class_self"]
    pub static mut scm_class_self: SCM;
}
extern "C" {
    #[link_name = "scm_class_protected"]
    pub static mut scm_class_protected: SCM;
}
extern "C" {
    #[link_name = "scm_class_hidden"]
    pub static mut scm_class_hidden: SCM;
}
extern "C" {
    #[link_name = "scm_class_opaque"]
    pub static mut scm_class_opaque: SCM;
}
extern "C" {
    #[link_name = "scm_class_read_only"]
    pub static mut scm_class_read_only: SCM;
}
extern "C" {
    #[link_name = "scm_class_protected_hidden"]
    pub static mut scm_class_protected_hidden: SCM;
}
extern "C" {
    #[link_name = "scm_class_protected_opaque"]
    pub static mut scm_class_protected_opaque: SCM;
}
extern "C" {
    #[link_name = "scm_class_protected_read_only"]
    pub static mut scm_class_protected_read_only: SCM;
}
extern "C" {
    #[link_name = "scm_class_scm"]
    pub static mut scm_class_scm: SCM;
}
extern "C" {
    #[link_name = "scm_class_int"]
    pub static mut scm_class_int: SCM;
}
extern "C" {
    #[link_name = "scm_class_float"]
    pub static mut scm_class_float: SCM;
}
extern "C" {
    #[link_name = "scm_class_double"]
    pub static mut scm_class_double: SCM;
}
extern "C" {
    #[link_name = "scm_smob_class"]
    pub static mut scm_smob_class: *mut SCM;
}
extern "C" {
    pub fn scm_init_deprecated_goops();
}
extern "C" {
    pub fn scm_compute_applicable_methods(gf: SCM, args: SCM,
                                          len: ::std::os::raw::c_long,
                                          scm_find_method:
                                              ::std::os::raw::c_int) -> SCM;
}
extern "C" {
    pub fn scm_find_method(l: SCM) -> SCM;
}
extern "C" {
    pub fn scm_basic_make_class(c: SCM, name: SCM, dsupers: SCM, dslots: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_get_keyword(kw: SCM, initargs: SCM, default_value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_ref_using_class(cls: SCM, obj: SCM, slot_name: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_slot_set_using_class_x(cls: SCM, obj: SCM, slot_name: SCM,
                                      value: SCM) -> SCM;
}
extern "C" {
    pub fn scm_slot_bound_using_class_p(cls: SCM, obj: SCM, slot_name: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_slot_exists_using_class_p(cls: SCM, obj: SCM, slot_name: SCM)
     -> SCM;
}
extern "C" {
    pub fn scm_make_arbiter(name: SCM) -> SCM;
}
extern "C" {
    pub fn scm_try_arbiter(arb: SCM) -> SCM;
}
extern "C" {
    pub fn scm_release_arbiter(arb: SCM) -> SCM;
}
extern "C" {
    pub fn scm_async(thunk: SCM) -> SCM;
}
extern "C" {
    pub fn scm_async_mark(a: SCM) -> SCM;
}
extern "C" {
    pub fn scm_run_asyncs(list_of_a: SCM) -> SCM;
}
extern "C" {
    pub fn scm_critical_section_start();
}
extern "C" {
    pub fn scm_critical_section_end();
}
extern "C" {
    pub fn scm_dynwind_critical_section(mutex: SCM);
}
extern "C" {
    pub fn scm_make_mutex_with_flags(flags: SCM) -> SCM;
}
extern "C" {
    pub fn scm_unlock_mutex_timed(mx: SCM, cond: SCM, timeout: SCM) -> SCM;
}
extern "C" {
    pub fn scm_lock_mutex_timed(m: SCM, timeout: SCM, owner: SCM) -> SCM;
}
extern "C" {
    pub fn scm_internal_cwdr(body: scm_t_catch_body,
                             body_data: *mut ::std::os::raw::c_void,
                             handler: scm_t_catch_handler,
                             handler_data: *mut ::std::os::raw::c_void,
                             stack_start: *mut SCM_STACKITEM) -> SCM;
}
extern "C" {
    pub fn scm_call_with_dynamic_root(thunk: SCM, handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_dynamic_root() -> SCM;
}
extern "C" {
    pub fn scm_apply_with_dynamic_root(proc_: SCM, a1: SCM, args: SCM,
                                       handler: SCM) -> SCM;
}
extern "C" {
    pub fn scm_make_dynamic_state(parent: SCM) -> SCM;
}
extern "C" {
    pub fn scm_from_contiguous_array(bounds: SCM, elts: *const SCM,
                                     len: usize) -> SCM;
}
extern "C" {
    pub fn SCM_FDES_RANDOM_P(fdes: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scm_i_init_deprecated();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct scm_vm {
    pub _address: u8,
}
impl Clone for scm_vm {
    fn clone(&self) -> Self { *self }
}
